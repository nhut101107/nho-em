# -*- coding: utf-8 -*-

# === Import Th∆∞ vi·ªán ===
import telebot
import json
import logging
import os
import random
import time
import threading # C·∫ßn cho /thongbao, x√≥a tin nh·∫Øn delay v√† schedule
import sqlite3
import requests # C·∫ßn cho c√°c API (/thoitiet, /phim, /rutgon, /fl, /flauto)
import qrcode   # C·∫ßn cho l·ªánh /qr
from io import BytesIO # C·∫ßn cho l·ªánh /qr
from datetime import datetime, timedelta, date # C·∫ßn cho /time, /plan, /diemdanh
from pathlib import Path
from threading import Lock
import html # D√πng ƒë·ªÉ escape HTML entities
from functools import wraps # C·∫ßn thi·∫øt cho decorator
import schedule # <<< TH√äM M·ªöI - C·∫ßn cho /flauto

# === C·∫•u h√¨nh ===
# --- B·∫Øt bu·ªôc thay ƒë·ªïi ---
BOT_TOKEN = "7352828711:AAEM-kWD-A8PXrjpYKLbHAn-MRVXKMzzmK0"             # !!! THAY TOKEN BOT C·ª¶A B·∫†N !!!
ADMIN_ID = 5992662564                          # !!! THAY ID TELEGRAM ADMIN C·ª¶A B·∫†N !!!
ADMIN_USERNAME = "mnhutdznecon"          # !!! THAY USERNAME ADMIN (kh√¥ng c√≥ @) !!!
WEATHER_API_KEY = "a40c3955762a3e2ccbd83c25ece1cf5c" # !!! THAY API KEY TH·ªúI TI·∫æT !!!
TMDB_API_KEY = "2a551c919f8c5fe445096179fc184ac3"            # !!! THAY API KEY C·ª¶A TMDb !!!
TIKTOK_FL_API_BASE_URL = "https://apitangfltiktok.soundcast.me/telefl.php" # <<< API URL TƒÇNG FL TIKTOK >>>

# --- ID NH√ìM ƒê∆Ø·ª¢C PH√âP HO·∫†T ƒê·ªòNG ---
ALLOWED_GROUP_ID = -1001931537243 # <<< ID NH√ìM C·ªê ƒê·ªäNH >>>

# --- ƒê∆∞·ªùng d·∫´n file ---
BASE_DIR = Path(__file__).parent
DATA_FILE_PATH = BASE_DIR / "taixiu_data_telebot.json" # File d·ªØ li·ªáu game (JSON)
DB_FILE_PATH = BASE_DIR / "user_vip_data.db"          # File database VIP (SQLite)
QR_CODE_IMAGE_PATH = BASE_DIR / "vietqr_payment.png"  # File ·∫£nh QR cho /muavip (C·∫ßn t·∫°o s·∫µn)

# --- Th√¥ng tin VIP & Ng√¢n h√†ng ---
VIP_PRICE = "50K"
VIP_DURATION_DAYS = 30
BANK_NAME = "MB Bank"
ACCOUNT_NUMBER = "17363999999999" # Thay STK th·∫≠t n·∫øu c·∫ßn
ACCOUNT_NAME = "BUI MINH NHUT"    # Thay t√™n TK th·∫≠t n·∫øu c·∫ßn
MAX_VIP_DURATION_DAYS = 18250 # ~50 nƒÉm

# --- C·∫•u h√¨nh Game ---
HOUSE_EDGE_PERCENT = 5 # T·ª∑ l·ªá l·ª£i th·∫ø nh√† c√°i (%) cho T√†i X·ªâu
JACKPOT_AMOUNT = 100000000
JACKPOT_CHANCE_ONE_IN = 5000 # T·ª∑ l·ªá 1/5000 tr√∫ng Jackpot m·ªói l·∫ßn ch∆°i T√†i X·ªâu
DELETE_DELAY = 15 # Gi√¢y
CHECKIN_REWARD = 50000   # <<< THAY ƒê·ªîI - Gi·∫£m ph·∫ßn th∆∞·ªüng ƒëi·ªÉm danh
PLAY_COOLDOWN = 2 # Gi√¢y ch·ªù gi·ªØa c√°c l·∫ßn ch∆°i T√†i X·ªâu
BAUCUA_COOLDOWN = 2 # Gi√¢y ch·ªù gi·ªØa c√°c l·∫ßn ch∆°i B·∫ßu Cua
TOP_N = 10 # S·ªë l∆∞·ª£ng ng∆∞·ªùi hi·ªÉn th·ªã trong /top
BAUCUA_ITEMS = ["b·∫ßu", "cua", "t√¥m", "c√°", "g√†", "nai"]
BAUCUA_ICONS = {"b·∫ßu": "üçê", "cua": "ü¶Ä", "t√¥m": "ü¶ê", "c√°": "üêü", "g√†": "üêì", "nai": "ü¶å"}

# --- C·∫•u h√¨nh L·ªánh M·ªõi ---
FLAUTO_COST = 100000      # <<< TH√äM M·ªöI - Chi ph√≠ cho /flauto
FLAUTO_INTERVAL_MINUTES = 16 # <<< TH√äM M·ªöI - Kho·∫£ng th·ªùi gian t·ª± ƒë·ªông fl (ph√∫t)

# === Logging ===
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# === Qu·∫£n l√Ω d·ªØ li·ªáu & Tr·∫°ng th√°i ===
data_lock = Lock()
start_time = datetime.now()
last_command_time = {}
allowed_vip_users = set()
maintenance_mode = False
MAINTENANCE_MESSAGE = "üõ†Ô∏è Bot ƒëang b·∫£o tr√¨ ƒë·ªÉ n√¢ng c·∫•p. Vui l√≤ng th·ª≠ l·∫°i sau √≠t ph√∫t! ‚è≥"
auto_follow_tasks = {} # <<< TH√äM M·ªöI - L∆∞u tr·ªØ c√°c t√°c v·ª• /flauto ƒëang ch·∫°y {user_id: {'tiktok_username': '...', 'job': schedule_job}}
scheduler_lock = Lock() # <<< TH√äM M·ªöI - Kh√≥a ƒë·ªÉ qu·∫£n l√Ω t√°c v·ª• schedule an to√†n

# === Decorator Ki·ªÉm Tra Nh√≥m ===
def kiem_tra_nhom_cho_phep(func):
    @wraps(func)
    def wrapper(message: telebot.types.Message, *args, **kwargs):
        if message.chat.id == ALLOWED_GROUP_ID:
            return func(message, *args, **kwargs)
        else:
            # Cho ph√©p admin d√πng l·ªánh ·ªü b·∫•t c·ª© ƒë√¢u (trong PM ch·∫≥ng h·∫°n)
            if message.from_user.id == ADMIN_ID:
                 logger.info(f"Admin {ADMIN_ID} d√πng l·ªánh '{message.text}' ngo√†i nh√≥m cho ph√©p (ID: {message.chat.id}).")
                 return func(message, *args, **kwargs)
            else:
                logger.info(f"L·ªánh '{message.text}' b·ªã b·ªè qua t·ª´ chat ID {message.chat.id} (kh√¥ng ƒë∆∞·ª£c ph√©p).")
                return
    return wrapper

# === C√°c h√†m ti·ªán √≠ch ===
def format_xu(amount: int | float) -> str:
    try:
        if isinstance(amount, float) and amount.is_integer(): amount = int(amount)
        if isinstance(amount, float): amount = round(amount)
        return f"{amount:,.0f}".replace(",", ".")
    except (ValueError, TypeError):
        return str(amount)

def get_user_info_from_message(message: telebot.types.Message) -> tuple[int, str]:
    user = message.from_user
    user_id = user.id
    user_name = user.username or f"{user.first_name} {user.last_name or ''}".strip() or f"User_{user_id}"
    safe_user_name = html.escape(user_name)
    return user_id, safe_user_name

def get_user_profile_info(user_id: int) -> str:
    try:
        chat = bot.get_chat(user_id)
        uid = chat.id
        fname = html.escape(chat.first_name or "")
        lname = html.escape(chat.last_name or "")
        full_name = f"{fname} {lname}".strip()
        uname = chat.username
        safe_bio = "üìù Kh√¥ng th·ªÉ l·∫•y ho·∫∑c kh√¥ng c√≥."
        try:
             maybe_bio = getattr(chat, 'bio', None)
             if maybe_bio:
                 safe_bio = f"üìù {html.escape(maybe_bio)}"
        except Exception: pass

        mention_link = f"<a href='tg://user?id={uid}'>{full_name or '·∫®n Danh'}</a>"
        info_lines = [
            "üë§‚ú® <b>Th√¥ng tin ng∆∞·ªùi d√πng</b> ‚ú®üë§",
            "-----------------------------",
            f"üÜî ID: <code>{uid}</code>",
            f"üìù T√™n: {mention_link}",
            f"üîó Username: @{uname}" if uname else "üîó Username: üëª Kh√¥ng c√≥",
            f"üìú Bio: {safe_bio}"
        ]
        return "\n".join(info_lines)
    except telebot.apihelper.ApiTelegramException as e:
        error_msg = str(e).lower()
        logger.warning(f"L·ªói API khi l·∫•y th√¥ng tin user {user_id}: {e}")
        if "chat not found" in error_msg or "user not found" in error_msg:
            return f"‚ùå Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng v·ªõi ID <code>{user_id}</code>."
        elif "bot can't initiate conversation" in error_msg:
             return f"‚ùå T√¥i kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu tr√≤ chuy·ªán v·ªõi ng∆∞·ªùi d√πng ID <code>{user_id}</code>."
        else:
            return f"‚ùå L·ªói API Telegram: {html.escape(str(e))}"
    except Exception as e:
        logger.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh khi l·∫•y th√¥ng tin user {user_id}: {e}", exc_info=True)
        return f"‚ùå L·ªói kh√¥ng mong mu·ªën khi l·∫•y th√¥ng tin ID <code>{user_id}</code>."

# === Database Setup (SQLite cho VIP Users) ===
def initialize_vip_database():
    try:
        conn = sqlite3.connect(DB_FILE_PATH, check_same_thread=False)
        cursor = conn.cursor()
        cursor.execute('''CREATE TABLE IF NOT EXISTS vip_users (
                            user_id INTEGER PRIMARY KEY,
                            expiration_time TEXT NOT NULL
                          )''')
        conn.commit(); conn.close()
        logger.info(f"üíæ ƒê√£ kh·ªüi t·∫°o/k·∫øt n·ªëi database VIP: {DB_FILE_PATH}")
    except Exception as e: logger.error(f"üÜò L·ªói kh·ªüi t·∫°o database VIP: {e}", exc_info=True)

def load_vip_users_from_db():
    global allowed_vip_users
    try:
        conn = sqlite3.connect(DB_FILE_PATH, check_same_thread=False); conn.row_factory = sqlite3.Row
        cursor = conn.cursor(); cursor.execute('SELECT user_id, expiration_time FROM vip_users'); rows = cursor.fetchall(); conn.close()
        current_time = datetime.now(); valid_vips = set(); expired_vips_to_delete = []
        for row in rows:
            user_id = row['user_id']; exp_time_str = row['expiration_time']
            try:
                exp_time = datetime.fromisoformat(exp_time_str)
                if exp_time > current_time: valid_vips.add(user_id)
                else: expired_vips_to_delete.append(user_id)
            except (ValueError, TypeError): logger.warning(f"DB VIP: Format time l·ªói user {user_id}: {exp_time_str}")
        allowed_vip_users = valid_vips; logger.info(f"‚úÖ ƒê√£ load {len(allowed_vip_users)} VIP users h·ª£p l·ªá.")
        if expired_vips_to_delete:
            logger.info(f"üóëÔ∏è ƒêang x√≥a {len(expired_vips_to_delete)} VIP users h·∫øt h·∫°n...")
            conn_del = sqlite3.connect(DB_FILE_PATH, check_same_thread=False); cursor_del = conn_del.cursor()
            cursor_del.executemany("DELETE FROM vip_users WHERE user_id = ?", [(uid,) for uid in expired_vips_to_delete])
            conn_del.commit(); conn_del.close(); logger.info(f"‚úÖ ƒê√£ x√≥a {len(expired_vips_to_delete)} VIP users h·∫øt h·∫°n.")
    except Exception as e: logger.error(f"üÜò L·ªói load VIP users: {e}", exc_info=True); allowed_vip_users = set()

def save_vip_user_to_db(user_id: int, duration_days: int) -> tuple[bool, datetime | str]:
    if not (0 < duration_days <= MAX_VIP_DURATION_DAYS): return False, f"‚ö†Ô∏è S·ªë ng√†y VIP ph·∫£i t·ª´ 1 ƒë·∫øn {MAX_VIP_DURATION_DAYS}."
    try:
        current_expiration = get_vip_expiration_time_from_db(user_id); start_date = datetime.now()
        if current_expiration and current_expiration > start_date: start_date = current_expiration
        expiration_time = start_date + timedelta(days=duration_days)
        conn = sqlite3.connect(DB_FILE_PATH, check_same_thread=False); cursor = conn.cursor()
        cursor.execute('INSERT OR REPLACE INTO vip_users (user_id, expiration_time) VALUES (?, ?)', (user_id, expiration_time.isoformat()))
        conn.commit(); conn.close(); logger.info(f"üíæ L∆∞u/Update VIP user {user_id}, h·∫øt h·∫°n {expiration_time.isoformat()}")
        load_vip_users_from_db(); return True, expiration_time
    except OverflowError: logger.error(f"üÜò L·ªói tr√†n s·ªë khi t√≠nh ng√†y h·∫øt h·∫°n VIP cho user {user_id}, {duration_days} ng√†y."); return False, "üÜò L·ªói tr√†n s·ªë (th·ªùi gian qu√° xa)."
    except Exception as e: logger.error(f"üÜò L·ªói l∆∞u VIP user {user_id}: {e}", exc_info=True); return False, f"üÜò L·ªói DB: {e}"

def delete_vip_user_from_db(target_user_id: int) -> bool:
    try:
        conn = sqlite3.connect(DB_FILE_PATH, check_same_thread=False); cursor = conn.cursor()
        cursor.execute("DELETE FROM vip_users WHERE user_id = ?", (target_user_id,)); conn.commit()
        deleted_rows = cursor.rowcount; conn.close()
        if deleted_rows > 0: logger.info(f"üóëÔ∏è ƒê√£ x√≥a VIP user {target_user_id}."); allowed_vip_users.discard(target_user_id); return True
        return False
    except Exception as e: logger.error(f"üÜò L·ªói x√≥a VIP user {target_user_id}: {e}", exc_info=True); return False

def get_vip_expiration_time_from_db(user_id: int) -> datetime | None:
    try:
        conn = sqlite3.connect(DB_FILE_PATH, check_same_thread=False); cursor = conn.cursor()
        cursor.execute("SELECT expiration_time FROM vip_users WHERE user_id = ?", (user_id,)); result = cursor.fetchone(); conn.close()
        if result:
            try: return datetime.fromisoformat(result[0])
            except (ValueError, TypeError): logger.warning(f"DB VIP: Format time l·ªói khi ƒë·ªçc user {user_id}: {result[0]}"); return None
        return None
    except Exception as e: logger.error(f"üÜò L·ªói query h·∫°n VIP user {user_id}: {e}", exc_info=True); return None

# === C√°c h√†m load/save/get data game (JSON) ===
def load_game_data_sync() -> dict:
    with data_lock:
        try:
            if DATA_FILE_PATH.exists() and DATA_FILE_PATH.stat().st_size > 0:
                with open(DATA_FILE_PATH, "r", encoding="utf-8") as f: return json.load(f)
            logger.warning(f"‚ö†Ô∏è File data game {DATA_FILE_PATH} tr·ªëng ho·∫∑c kh√¥ng t·ªìn t·∫°i. T·∫°o m·ªõi."); return {}
        except json.JSONDecodeError: logger.error(f"üÜò L·ªói gi·∫£i m√£ JSON trong file {DATA_FILE_PATH}. Tr·∫£ v·ªÅ d·ªØ li·ªáu tr·ªëng.", exc_info=True); return {}
        except Exception as e: logger.error(f"üÜò L·ªói ƒë·ªçc file {DATA_FILE_PATH}: {e}. Tr·∫£ v·ªÅ d·ªØ li·ªáu tr·ªëng.", exc_info=True); return {}

def save_game_data_sync(data: dict):
    with data_lock:
        temp_file_path = DATA_FILE_PATH.with_suffix(".json.tmp")
        try:
            with open(temp_file_path, "w", encoding="utf-8") as f: json.dump(data, f, indent=4, ensure_ascii=False)
            os.replace(temp_file_path, DATA_FILE_PATH)
        except Exception as e:
            logger.error(f"üÜò L·ªói nghi√™m tr·ªçng khi l∆∞u game data v√†o {DATA_FILE_PATH}: {e}", exc_info=True)
            if temp_file_path.exists():
                try: temp_file_path.unlink()
                except OSError as rm_err: logger.error(f"üÜò Kh√¥ng th·ªÉ x√≥a file t·∫°m {temp_file_path} sau l·ªói l∆∞u: {rm_err}")

def get_player_data(user_id: int, user_name: str, data: dict) -> dict:
    uid = str(user_id)
    safe_user_name = user_name
    player_info = data.get(uid)

    if player_info is None:
        player_info = {
            "name": safe_user_name, "xu": 100000, "plays": 0, "last_checkin_date": None
        }
        data[uid] = player_info
        logger.info(f"‚ú® T·∫°o ng∆∞·ªùi ch∆°i m·ªõi: ID={uid}, T√™n='{safe_user_name}', Xu={player_info['xu']}")
    else:
        # Lu√¥n c·∫≠p nh·∫≠t t√™n n·∫øu c√≥ thay ƒë·ªïi
        if player_info.get("name") != safe_user_name:
            logger.info(f"üîÑ C·∫≠p nh·∫≠t t√™n ng∆∞·ªùi ch∆°i {uid}: '{player_info.get('name', 'N/A')}' -> '{safe_user_name}'")
            player_info["name"] = safe_user_name
        # ƒê·∫£m b·∫£o c√°c tr∆∞·ªùng c∆° b·∫£n t·ªìn t·∫°i
        player_info.setdefault("xu", 0)
        player_info.setdefault("plays", 0)
        player_info.setdefault("last_checkin_date", None)

    return player_info

# === Logic Game ===
def roll_dice_sync() -> tuple[list[int], int, str]:
    dice = [random.randint(1, 6) for _ in range(3)]; total = sum(dice)
    result = "t√†i" if 11 <= total <= 18 else "x·ªâu"; return dice, total, result

def roll_baucua_sync() -> list[str]:
    return random.choices(BAUCUA_ITEMS, k=3)

# === Kh·ªüi t·∫°o Bot ===
bot = telebot.TeleBot(BOT_TOKEN, parse_mode='HTML')
logger.info("üöÄ TeleBot instance ƒë√£ ƒë∆∞·ª£c t·∫°o.")

# === H√†m x√≥a tin nh·∫Øn sau delay ===
def delete_message_after_delay(chat_id: int, message_id: int, delay: int):
    def delete_task():
        try:
            time.sleep(delay)
            bot.delete_message(chat_id=chat_id, message_id=message_id)
        except telebot.apihelper.ApiTelegramException as e:
            if "message to delete not found" in str(e).lower() or "message identifier is not specified" in str(e).lower():
                pass
            else:
                logger.warning(f"‚ö†Ô∏è L·ªói API khi x√≥a tin nh·∫Øn {message_id} trong chat {chat_id}: {e}")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è L·ªói kh√¥ng x√°c ƒë·ªãnh khi x√≥a tin nh·∫Øn {message_id} trong chat {chat_id}: {e}")

    if delay > 0:
        thread = threading.Thread(target=delete_task, daemon=True)
        thread.start()

# === Middleware ki·ªÉm tra b·∫£o tr√¨ ===
@bot.message_handler(func=lambda message: maintenance_mode and message.from_user.id != ADMIN_ID)
def handle_maintenance(message: telebot.types.Message):
    try:
        # Ch·ªâ tr·∫£ l·ªùi n·∫øu tin nh·∫Øn ƒë·∫øn t·ª´ nh√≥m ƒë∆∞·ª£c ph√©p ho·∫∑c t·ª´ admin (d√π admin b·ªè qua check n√†y)
        if message.chat.id == ALLOWED_GROUP_ID or message.from_user.id == ADMIN_ID:
            if message.text and message.text.startswith('/'): # Ch·ªâ tr·∫£ l·ªùi l·ªánh
                bot.reply_to(message, MAINTENANCE_MESSAGE)
    except Exception as e:
        logger.error(f"üÜò L·ªói g·ª≠i tin nh·∫Øn b·∫£o tr√¨ cho user {message.from_user.id}: {e}")

# === H√†m ch·∫°y API t·ª± ƒë·ªông (/flauto) ===
def _run_auto_follow(user_id: int, tiktok_username: str):
    """H√†m ƒë∆∞·ª£c schedule g·ªçi ƒë·ªÉ th·ª±c hi·ªán tƒÉng follow t·ª± ƒë·ªông."""
    api_url = f"{TIKTOK_FL_API_BASE_URL}?user={tiktok_username}&userid={user_id}&tokenbot={BOT_TOKEN}"
    logger.info(f"ü§ñ [AutoFL] ƒêang ch·∫°y t√°c v·ª• cho User {user_id}, TikTok '{tiktok_username}'...")
    try:
        response = requests.get(api_url, timeout=25)
        response.raise_for_status()
        logger.info(f"‚úÖ [AutoFL] G·ªçi API th√†nh c√¥ng cho User {user_id}, TikTok '{tiktok_username}'. Response: {response.text[:100]}...")
        # G·ª≠i th√¥ng b√°o th√†nh c√¥ng (t√πy ch·ªçn, c√≥ th·ªÉ t·∫Øt n·∫øu g√¢y spam)
        # try:
        #     bot.send_message(user_id, f"‚ú® T√°c v·ª• t·ª± ƒë·ªông tƒÉng follow cho @{html.escape(tiktok_username)} v·ª´a ƒë∆∞·ª£c th·ª±c hi·ªán.", parse_mode='HTML')
        # except Exception as send_err:
        #     logger.warning(f"‚ö†Ô∏è [AutoFL] Kh√¥ng th·ªÉ g·ª≠i th√¥ng b√°o th√†nh c√¥ng cho user {user_id}: {send_err}")
    except requests.exceptions.Timeout:
        logger.error(f"‚è≥ [AutoFL] Timeout khi g·ªçi API cho User {user_id}, TikTok '{tiktok_username}'")
    except requests.exceptions.RequestException as e:
        status_code = e.response.status_code if e.response is not None else "N/A"
        logger.error(f"üÜò [AutoFL] L·ªói k·∫øt n·ªëi/API (Code: {status_code}) cho User {user_id}, TikTok '{tiktok_username}': {e}")
        # Th√¥ng b√°o l·ªói cho ng∆∞·ªùi d√πng (t√πy ch·ªçn)
        # try:
        #     bot.send_message(user_id, f"‚ùå L·ªói khi t·ª± ƒë·ªông tƒÉng follow cho @{html.escape(tiktok_username)}. API g·∫∑p s·ª± c·ªë (Code: {status_code}). T√°c v·ª• v·∫´n ti·∫øp t·ª•c theo l·ªãch.", parse_mode='HTML')
        # except Exception as send_err:
        #      logger.warning(f"‚ö†Ô∏è [AutoFL] Kh√¥ng th·ªÉ g·ª≠i th√¥ng b√°o l·ªói cho user {user_id}: {send_err}")
    except Exception as e:
        logger.error(f"üÜò [AutoFL] L·ªói kh√¥ng mong mu·ªën khi ch·∫°y t√°c v·ª• cho User {user_id}, TikTok '{tiktok_username}': {e}", exc_info=True)

# === H√†m ch·∫°y Scheduler trong Thread ri√™ng ===
def _scheduler_loop():
    """V√≤ng l·∫∑p ch·∫°y ki·ªÉm tra v√† th·ª±c thi c√°c t√°c v·ª• ƒë√£ ƒë∆∞·ª£c l√™n l·ªãch."""
    logger.info("‚è∞ B·∫Øt ƒë·∫ßu v√≤ng l·∫∑p scheduler...")
    while True:
        try:
            with scheduler_lock: # ƒê·∫£m b·∫£o an to√†n khi truy c·∫≠p schedule
                 schedule.run_pending()
        except Exception as e:
            logger.error(f"üÜò L·ªói trong v√≤ng l·∫∑p scheduler: {e}", exc_info=True)
            # Ng·ªß m·ªôt ch√∫t ƒë·ªÉ tr√°nh v√≤ng l·∫∑p l·ªói qu√° nhanh
            time.sleep(5)
        time.sleep(1) # Ki·ªÉm tra m·ªói gi√¢y

# === C√°c l·ªánh ADMIN ===
@bot.message_handler(commands=['add'])
@kiem_tra_nhom_cho_phep
def add_vip_command(message: telebot.types.Message):
    user_id, _ = get_user_info_from_message(message)
    if user_id != ADMIN_ID: return bot.reply_to(message, "‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!")
    args = message.text.split()
    if len(args) < 2 or not args[1].isdigit():
        return bot.reply_to(message, f"‚ùå Sai c√∫ ph√°p! D√πng: <code>/add &lt;user_id&gt; [s·ªë_ng√†y]</code>\n(M·∫∑c ƒë·ªãnh l√† {VIP_DURATION_DAYS} ng√†y n·∫øu kh√¥ng nh·∫≠p)")
    try:
        target_user_id = int(args[1])
        duration_days = VIP_DURATION_DAYS
        if len(args) >= 3:
            try:
                duration_days = int(args[2])
                if not (0 < duration_days <= MAX_VIP_DURATION_DAYS):
                    return bot.reply_to(message, f"‚ö†Ô∏è S·ªë ng√†y VIP ph·∫£i l√† m·ªôt s·ªë d∆∞∆°ng v√† kh√¥ng qu√° {MAX_VIP_DURATION_DAYS} ng√†y.")
            except ValueError:
                return bot.reply_to(message, "‚ö†Ô∏è S·ªë ng√†y VIP ph·∫£i l√† m·ªôt s·ªë nguy√™n h·ª£p l·ªá.")
        success, result_data = save_vip_user_to_db(target_user_id, duration_days)
        if success and isinstance(result_data, datetime):
            exp_str = result_data.strftime('%Y-%m-%d %H:%M:%S')
            reply_msg = f"‚úÖ‚ú® ƒê√£ c·∫•p/gia h·∫°n VIP th√†nh c√¥ng <b>{duration_days}</b> ng√†y cho ID <code>{target_user_id}</code>.\n‚è≥ Ng√†y h·∫øt h·∫°n m·ªõi: <b>{exp_str}</b>."
            bot.reply_to(message, reply_msg)
            try:
                # C·ªë g·∫Øng l·∫•y t√™n ng∆∞·ªùi d√πng ƒë∆∞·ª£c add VIP ƒë·ªÉ th√¥ng b√°o
                target_info = get_user_profile_info(target_user_id) # L·∫•y c·∫£ info ƒë·ªÉ c√≥ t√™n
                target_mention = f"ID <code>{target_user_id}</code>"
                try:
                    target_chat = bot.get_chat(target_user_id)
                    target_mention = f"<a href='tg://user?id={target_user_id}'>{html.escape(target_chat.first_name)}</a> (ID: <code>{target_user_id}</code>)"
                except Exception: pass # Kh√¥ng l·∫•y ƒë∆∞·ª£c t√™n th√¨ d√πng ID

                bot.send_message(target_user_id, f"üéâ Ch√∫c m·ª´ng! B·∫°n ƒë√£ ƒë∆∞·ª£c Admin c·∫•p/gia h·∫°n <b>{duration_days}</b> ng√†y VIP.\nüóìÔ∏è VIP c·ªßa b·∫°n s·∫Ω h·∫øt h·∫°n v√†o l√∫c: {exp_str}")
                logger.info(f"üëë Admin {user_id} ƒë√£ c·∫•p {duration_days} ng√†y VIP cho user {target_mention}")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn th√¥ng b√°o c·∫•p VIP cho user {target_user_id}: {e}")
                bot.reply_to(message, f"‚ÑπÔ∏è ƒê√£ c·∫•p VIP th√†nh c√¥ng nh∆∞ng kh√¥ng th·ªÉ g·ª≠i th√¥ng b√°o cho ID <code>{target_user_id}</code> (c√≥ th·ªÉ do h·ªç ƒë√£ ch·∫∑n bot ho·∫∑c l·ªói kh√°c).")
        else:
            bot.reply_to(message, f"‚ùå L·ªói khi th√™m VIP cho ID <code>{target_user_id}</code>: {result_data}")
            logger.error(f"üÜò Admin {user_id} g·∫∑p l·ªói khi th√™m VIP cho {target_user_id}: {result_data}")
    except ValueError:
        bot.reply_to(message, "‚ùå User ID kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p ID d·∫°ng s·ªë.")
    except Exception as e:
        logger.error(f"üÜò L·ªói kh√¥ng mong mu·ªën trong l·ªánh /add: {e}", exc_info=True)
        bot.reply_to(message, "‚ùå ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën trong qu√° tr√¨nh x·ª≠ l√Ω.")

@bot.message_handler(commands=['xoavip'])
@kiem_tra_nhom_cho_phep
def xoavip_command(message: telebot.types.Message):
    user_id, _ = get_user_info_from_message(message)
    if user_id != ADMIN_ID: return bot.reply_to(message, "‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!")
    args = message.text.split()
    if len(args) != 2 or not args[1].isdigit():
        return bot.reply_to(message, "‚ùå Sai c√∫ ph√°p! D√πng: <code>/xoavip &lt;user_id&gt;</code>")
    try:
        target_user_id = int(args[1])
        deleted = delete_vip_user_from_db(target_user_id)
        if deleted:
            bot.reply_to(message, f"‚úÖüóëÔ∏è ƒê√£ x√≥a th√†nh c√¥ng tr·∫°ng th√°i VIP c·ªßa ng∆∞·ªùi d√πng ID <code>{target_user_id}</code>.")
            logger.info(f"üóëÔ∏è Admin {user_id} ƒë√£ x√≥a VIP c·ªßa user {target_user_id}")
            try:
                bot.send_message(target_user_id, "‚ÑπÔ∏è Tr·∫°ng th√°i VIP c·ªßa b·∫°n ƒë√£ b·ªã qu·∫£n tr·ªã vi√™n thu h·ªìi.")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn th√¥ng b√°o thu h·ªìi VIP cho user {target_user_id}: {e}")
        else:
            bot.reply_to(message, f"‚ÑπÔ∏è Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng VIP v·ªõi ID <code>{target_user_id}</code> ho·∫∑c ƒë√£ c√≥ l·ªói x·∫£y ra khi x√≥a.")
            logger.warning(f"‚ö†Ô∏è Admin {user_id} x√≥a VIP user {target_user_id} th·∫•t b·∫°i (kh√¥ng t√¨m th·∫•y ho·∫∑c l·ªói DB).")
    except ValueError:
        bot.reply_to(message, "‚ùå User ID kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p ID d·∫°ng s·ªë.")
    except Exception as e:
        logger.error(f"üÜò L·ªói kh√¥ng mong mu·ªën trong l·ªánh /xoavip: {e}", exc_info=True)
        bot.reply_to(message, "‚ùå ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën trong qu√° tr√¨nh x·ª≠ l√Ω.")

@bot.message_handler(commands=['thongbao'])
@kiem_tra_nhom_cho_phep
def thongbao_command(message: telebot.types.Message):
     user_id, _ = get_user_info_from_message(message)
     if user_id != ADMIN_ID: return bot.reply_to(message, "‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn!")
     args = message.text.split(maxsplit=1)
     if len(args) < 2 or not args[1].strip():
        return bot.reply_to(message, "‚ùå Vui l√≤ng nh·∫≠p n·ªôi dung th√¥ng b√°o: <code>/thongbao [N·ªôi dung c·∫ßn g·ª≠i]</code>")
     broadcast_message = f"üì¢ <b>Th√¥ng B√°o T·ª´ Admin:</b>\n\n{args[1].strip()}"
     game_data = load_game_data_sync()
     user_ids_str = list(game_data.keys())
     if not user_ids_str:
        return bot.reply_to(message, "‚ÑπÔ∏è Kh√¥ng c√≥ ng∆∞·ªùi d√πng n√†o trong d·ªØ li·ªáu ƒë·ªÉ g·ª≠i th√¥ng b√°o.")
     total_users = len(user_ids_str)
     sent_count = 0; failed_count = 0; blocked_count = 0
     logger.info(f"üì¢ Admin {ADMIN_ID} b·∫Øt ƒë·∫ßu g·ª≠i th√¥ng b√°o ƒë·∫øn {total_users} ng∆∞·ªùi d√πng...")
     confirm_msg = None
     try: confirm_msg = bot.reply_to(message, f"‚è≥ Chu·∫©n b·ªã g·ª≠i th√¥ng b√°o ƒë·∫øn <b>{total_users}</b> ng∆∞·ªùi d√πng... Vui l√≤ng ch·ªù!")
     except Exception as e: logger.error(f"üÜò L·ªói g·ª≠i tin nh·∫Øn x√°c nh·∫≠n /thongbao: {e}"); return

     def broadcast_thread_func(confirm_msg_obj):
        nonlocal sent_count, failed_count, blocked_count
        for user_id_str in user_ids_str:
            try:
                user_id_int = int(user_id_str)
                bot.send_message(user_id_int, broadcast_message)
                sent_count += 1
                time.sleep(0.1) # Delay nh·ªè ƒë·ªÉ tr√°nh rate limit
            except ValueError:
                logger.warning(f"‚ö†Ô∏è B·ªè qua ID kh√¥ng h·ª£p l·ªá trong /thongbao: {user_id_str}")
                failed_count += 1
            except telebot.apihelper.ApiTelegramException as e:
                error_str = str(e).lower()
                if "forbidden: bot was blocked by the user" in error_str or "chat not found" in error_str or "user is deactivated" in error_str:
                    blocked_count += 1
                    # T√πy ch·ªçn: X√≥a user ƒë√£ ch·∫∑n/deactivate kh·ªèi DB?
                    # delete_vip_user_from_db(user_id_int)
                    # with data_lock:
                    #     game_data_local = load_game_data_sync()
                    #     if user_id_str in game_data_local:
                    #         del game_data_local[user_id_str]
                    #         save_game_data_sync(game_data_local)
                    # logger.info(f"üö´ User {user_id_str} b·ªã ch·∫∑n/kh√¥ng t·ªìn t·∫°i, ƒë√£ x√≥a kh·ªèi d·ªØ li·ªáu (n·∫øu c√≥).")
                else:
                    logger.warning(f"‚ö†Ô∏è L·ªói API khi g·ª≠i th√¥ng b√°o ƒë·∫øn {user_id_str}: {e}")
                    failed_count += 1
                time.sleep(0.5) # Delay l·ªõn h∆°n n·∫øu g·∫∑p l·ªói API
            except Exception as e:
                logger.error(f"üÜò L·ªói kh√¥ng x√°c ƒë·ªãnh khi g·ª≠i ƒë·∫øn {user_id_str}: {e}", exc_info=True)
                failed_count += 1
                time.sleep(0.5)

        logger.info(f"üì¢ Th√¥ng b√°o ho√†n t·∫•t: Th√†nh c√¥ng={sent_count}, L·ªói={failed_count}, B·ªã ch·∫∑n/Kh√¥ng t√¨m th·∫•y={blocked_count}")
        result_text = (f"‚úÖ <b>Th√¥ng b√°o ho√†n t·∫•t!</b>\n--------------------------\n‚úîÔ∏è G·ª≠i th√†nh c√¥ng: <b>{sent_count}</b>\n"
                       f"‚ùå G·ª≠i th·∫•t b·∫°i: <b>{failed_count}</b>\n"
                       f"üö´ B·ªã ch·∫∑n/Kh√¥ng t√¨m th·∫•y: <b>{blocked_count}</b>")
        try:
            if confirm_msg_obj:
                 bot.edit_message_text(result_text, chat_id=confirm_msg_obj.chat.id, message_id=confirm_msg_obj.message_id)
            else: # N·∫øu tin nh·∫Øn x√°c nh·∫≠n ban ƒë·∫ßu b·ªã l·ªói
                 bot.send_message(ADMIN_ID, result_text)
        except Exception as edit_e:
            logger.error(f"üÜò L·ªói kh√¥ng th·ªÉ s·ª≠a/g·ª≠i tin nh·∫Øn k·∫øt qu·∫£ th√¥ng b√°o: {edit_e}")
            bot.send_message(ADMIN_ID, result_text) # G·ª≠i tin nh·∫Øn m·ªõi cho admin

     broadcast_thread = threading.Thread(target=broadcast_thread_func, args=(confirm_msg,), daemon=True)
     broadcast_thread.start()

@bot.message_handler(commands=['baotri'])
@kiem_tra_nhom_cho_phep
def baotri_command(message: telebot.types.Message):
    global maintenance_mode
    user_id, _ = get_user_info_from_message(message)
    if user_id != ADMIN_ID: return bot.reply_to(message, "‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn!")
    maintenance_mode = True; logger.info(f"üõ†Ô∏è Admin {ADMIN_ID} ƒë√£ B·∫¨T ch·∫ø ƒë·ªô b·∫£o tr√¨.")
    bot.reply_to(message, "‚úÖüõ†Ô∏è ƒê√£ b·∫≠t ch·∫ø ƒë·ªô b·∫£o tr√¨. Ch·ªâ Admin m·ªõi c√≥ th·ªÉ d√πng l·ªánh.")

@bot.message_handler(commands=['hoantat'])
@kiem_tra_nhom_cho_phep
def hoantat_command(message: telebot.types.Message):
    global maintenance_mode
    user_id, _ = get_user_info_from_message(message)
    if user_id != ADMIN_ID: return bot.reply_to(message, "‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn!")
    maintenance_mode = False; logger.info(f"‚úÖ Admin {ADMIN_ID} ƒë√£ T·∫ÆT ch·∫ø ƒë·ªô b·∫£o tr√¨.")
    bot.reply_to(message, "‚úÖüëç ƒê√£ t·∫Øt ch·∫ø ƒë·ªô b·∫£o tr√¨. Bot ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng.")

@bot.message_handler(commands=['cong'])
@kiem_tra_nhom_cho_phep
def cong_command(message: telebot.types.Message):
    user_id, _ = get_user_info_from_message(message)
    if user_id != ADMIN_ID: return bot.reply_to(message, "‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn!")
    args = message.text.split(); target_user_id = None; amount = None
    if len(args) == 3:
        try:
            target_user_id = int(args[1])
            amount_str = args[2].replace('.', '').replace(',', '') # X·ª≠ l√Ω d·∫•u ch·∫•m/ph·∫©y
            amount = int(amount_str)
            if amount <= 0:
                return bot.reply_to(message, "‚ùå S·ªë xu c·ªông ph·∫£i l√† s·ªë d∆∞∆°ng.")
        except ValueError:
            return bot.reply_to(message, "‚ùå Sai c√∫ ph√°p ho·∫∑c s·ªë kh√¥ng h·ª£p l·ªá.\nD√πng: <code>/cong [user_id] [s·ªë_xu]</code>")
    else:
        return bot.reply_to(message, "‚ùå Sai c√∫ ph√°p! D√πng: <code>/cong [user_id] [s·ªë_xu]</code>")

    game_data = load_game_data_sync()
    # C·ªë g·∫Øng l·∫•y t√™n th·∫≠t thay v√¨ t√™n t·∫°m th·ªùi
    target_name_temp = "User_" + str(target_user_id)
    try:
        target_chat = bot.get_chat(target_user_id)
        target_name_temp = target_chat.username or f"{target_chat.first_name} {target_chat.last_name or ''}".strip() or f"User_{target_user_id}"
    except Exception:
        pass # Kh√¥ng l·∫•y ƒë∆∞·ª£c t√™n th√¨ d√πng t√™n t·∫°m

    target_player = get_player_data(target_user_id, target_name_temp, game_data)
    target_player["xu"] += amount
    save_game_data_sync(game_data)
    logger.info(f"üí∏ Admin {user_id} ƒë√£ c·ªông {format_xu(amount)} xu cho {target_player['name']}(ID:{target_user_id}). S·ªë d∆∞ m·ªõi: {format_xu(target_player['xu'])}")
    bot.reply_to(message, f"‚úÖ ƒê√£ c·ªông th√†nh c√¥ng <b>{format_xu(amount)}</b> xu cho {html.escape(target_player['name'])} (ID: <code>{target_user_id}</code>).\nüí∞ S·ªë d∆∞ m·ªõi c·ªßa h·ªç: <b>{format_xu(target_player['xu'])}</b> xu.")

@bot.message_handler(commands=['truxu'])
@kiem_tra_nhom_cho_phep
def truxu_command(message: telebot.types.Message):
    user_id, user_name = get_user_info_from_message(message)
    if user_id != ADMIN_ID:
        return bot.reply_to(message, "‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!")

    logger.warning(f"üö® Admin {user_id} ({user_name}) ƒëang th·ª±c hi·ªán l·ªánh /truxu!")
    msg_confirm = bot.reply_to(message, "‚è≥ ƒêang x·ª≠ l√Ω tr·ª´ h·∫øt xu c·ªßa t·∫•t c·∫£ ng∆∞·ªùi d√πng... Vui l√≤ng ch·ªù.")

    try:
        game_data = load_game_data_sync()
        count = 0
        user_ids_affected = []

        for uid_str, player_info in game_data.items():
            # Ki·ªÉm tra xem c√≥ ph·∫£i l√† dict h·ª£p l·ªá v√† c√≥ key 'xu' kh√¥ng
            if isinstance(player_info, dict) and "xu" in player_info:
                 # Tr·ª´ c·∫£ admin n·∫øu mu·ªën, n·∫øu kh√¥ng th√¨ th√™m: and int(uid_str) != ADMIN_ID
                if player_info["xu"] != 0:
                    player_info["xu"] = 0
                    count += 1
                    user_ids_affected.append(uid_str)

        save_game_data_sync(game_data)
        logger.warning(f"üö® Admin {user_id} ƒë√£ tr·ª´ h·∫øt xu c·ªßa {count} ng∆∞·ªùi d√πng.")
        bot.edit_message_text(f"‚úÖ ƒê√£ tr·ª´ h·∫øt xu c·ªßa <b>{count}</b> ng∆∞·ªùi d√πng v·ªÅ 0 th√†nh c√¥ng!",
                              chat_id=msg_confirm.chat.id, message_id=msg_confirm.message_id)

        # T√πy ch·ªçn: G·ª≠i th√¥ng b√°o cho nh·ªØng ng∆∞·ªùi b·ªã ·∫£nh h∆∞·ªüng (c√≥ th·ªÉ g√¢y spam)
        # for affected_id_str in user_ids_affected:
        #     try:
        #         bot.send_message(int(affected_id_str), "‚ÑπÔ∏è T√†i kho·∫£n xu c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c Admin ƒë·∫∑t l·∫°i v·ªÅ 0.")
        #         time.sleep(0.1)
        #     except Exception:
        #         pass # B·ªè qua n·∫øu kh√¥ng g·ª≠i ƒë∆∞·ª£c

    except Exception as e:
        logger.error(f"üÜò L·ªói nghi√™m tr·ªçng khi th·ª±c hi·ªán /truxu: {e}", exc_info=True)
        try:
             bot.edit_message_text(f"‚ùå ƒê√£ x·∫£y ra l·ªói khi th·ª±c hi·ªán l·ªánh /truxu: {html.escape(str(e))}",
                                  chat_id=msg_confirm.chat.id, message_id=msg_confirm.message_id)
        except Exception: # N·∫øu s·ª≠a c≈©ng l·ªói th√¨ g·ª≠i m·ªõi
            bot.reply_to(message, f"‚ùå ƒê√£ x·∫£y ra l·ªói khi th·ª±c hi·ªán l·ªánh /truxu: {html.escape(str(e))}")

# === C√°c l·ªánh Ng∆∞·ªùi d√πng ===
@bot.message_handler(commands=['start', 'help'])
@kiem_tra_nhom_cho_phep
def start_help_command(message: telebot.types.Message):
    user_id, user_name = get_user_info_from_message(message)
    game_data = load_game_data_sync()
    player_data = get_player_data(user_id, user_name, game_data)
    save_game_data_sync(game_data) # L∆∞u l·∫°i n·∫øu ng∆∞·ªùi d√πng m·ªõi ƒë∆∞·ª£c t·∫°o

    is_admin = user_id == ADMIN_ID
    is_vip = user_id in allowed_vip_users
    vip_status_line = ""
    if is_vip:
        exp_time = get_vip_expiration_time_from_db(user_id)
        vip_status_line = f"üíé B·∫°n l√† th√†nh vi√™n <b>VIP</b>"
        if exp_time:
            vip_status_line += f" (H·∫øt h·∫°n: {exp_time.strftime('%d/%m/%Y %H:%M')})\n"
        else:
            vip_status_line += " (Kh√¥ng r√µ h·∫°n)\n"

    # C·∫≠p nh·∫≠t help text v·ªõi l·ªánh m·ªõi
    help_text = f"""
üëã Ch√†o {user_name}! S·ªë d∆∞ c·ªßa b·∫°n: üí∞ <b>{format_xu(player_data['xu'])}</b> xu.
{vip_status_line}
üìñ‚ú® <b>L·ªánh Ng∆∞·ªùi D√πng Th∆∞·ªùng</b> ‚ú®üìñ
‚î£‚îÄ /help - ‚ùì Xem h∆∞·ªõng d·∫´n n√†y
‚î£‚îÄ /muavip - üíé H∆∞·ªõng d·∫´n mua/gia h·∫°n VIP
‚î£‚îÄ /plan - üìÖ Ki·ªÉm tra th·ªùi h·∫°n VIP
‚î£‚îÄ /diemdanh - üéÅ Nh·∫≠n <b>{format_xu(CHECKIN_REWARD)}</b> xu mi·ªÖn ph√≠ m·ªói ng√†y
‚î£‚îÄ /check - üí∞ Xem s·ªë d∆∞ xu
‚î£‚îÄ /play <code>[t√†i|x·ªâu] [s·ªë_xu|all]</code> - üé≤ Ch∆°i T√†i X·ªâu
‚î£‚îÄ /baucua <code>[v·∫≠t] [s·ªë_xu|all|10k|1m]</code> - ü¶Ä Ch∆°i B·∫ßu Cua
‚î£‚îÄ /top - üèÜ Xem Top ƒê·∫°i Gia
‚î£‚îÄ /time - ‚è±Ô∏è Xem th·ªùi gian ho·∫°t ƒë·ªông c·ªßa Bot
‚î£‚îÄ /info <code>[reply/ID]</code> - üë§ Xem th√¥ng tin user Telegram
‚î£‚îÄ /qr <code>[n·ªôi dung]</code> - ‚ñà T·∫°o m√£ QR
‚î£‚îÄ /rutgon <code>[link]</code> - üîó R√∫t g·ªçn link URL
‚î£‚îÄ /thoitiet <code>[ƒë·ªãa ƒëi·ªÉm]</code> - üå¶Ô∏è Xem th·ªùi ti·∫øt
‚î£‚îÄ /phim <code>[t√™n phim]</code> - üé¨ T√¨m th√¥ng tin phim
‚î£‚îÄ /fl <code>[Username TikTok]</code> - ‚ú® TƒÉng follow TikTok (Th·ª≠ nghi·ªám)
‚î£‚îÄ /flauto <code>[Username TikTok]</code> - ü§ñ T·ª± ƒë·ªông FL ({FLAUTO_INTERVAL_MINUTES}p, t·ªën {format_xu(FLAUTO_COST)} xu)
‚î£‚îÄ /stopflauto - üö´ D·ª´ng t·ª± ƒë·ªông FL
‚îó‚îÄ /admin - üßë‚Äçüíº Li√™n h·ªá Admin
"""
    if is_vip:
        vip_commands_text = "\nüíéüëë <b>L·ªánh ƒê·∫∑c Quy·ªÅn VIP</b> üëëüíé\n(Hi·ªán ch∆∞a c√≥ l·ªánh VIP n√†o kh√°c)\n"
        help_text += vip_commands_text
    if is_admin:
        admin_commands_text = f"""
üîíüîë <b>L·ªánh Qu·∫£n Tr·ªã Vi√™n</b> üîëüîí
‚î£‚îÄ /add <code>[id] [ng√†y]</code> - ‚úÖ Th√™m/Gia h·∫°n VIP
‚î£‚îÄ /xoavip <code>[id]</code> - ‚ùå X√≥a VIP
‚î£‚îÄ /cong <code>[id] [xu]</code> - ‚ûï C·ªông xu
‚î£‚îÄ /truxu - ‚ûñ Tr·ª´ h·∫øt xu c·ªßa m·ªçi ng∆∞·ªùi v·ªÅ 0
‚î£‚îÄ /thongbao <code>[n·ªôi dung]</code> - üì¢ G·ª≠i th√¥ng b√°o chung
‚î£‚îÄ /baotri - üõ†Ô∏è B·∫≠t ch·∫ø ƒë·ªô b·∫£o tr√¨
‚îó‚îÄ /hoantat - ‚úÖ T·∫Øt ch·∫ø ƒë·ªô b·∫£o tr√¨
"""
        help_text += admin_commands_text

    help_text += f"\nCh√∫c {user_name} s·ª≠ d·ª•ng bot vui v·∫ª! üéâ"
    try:
        bot.reply_to(message, help_text, disable_web_page_preview=True)
    except telebot.apihelper.ApiTelegramException as e:
        if "can't parse entities" in str(e):
            logger.error(f"üÜò V·∫´n l·ªói parse HTML trong /help, g·ª≠i d·∫°ng text th∆∞·ªùng: {e}")
            plain_text_help = telebot.util.extract_tags(help_text)
            try:
                bot.reply_to(message, plain_text_help, disable_web_page_preview=True)
            except Exception as plain_e:
                logger.error(f"üÜò L·ªói g·ª≠i c·∫£ text th∆∞·ªùng c·ªßa /help: {plain_e}")
                bot.reply_to(message, "üò• L·ªói hi·ªÉn th·ªã tr·ª£ gi√∫p. Vui l√≤ng th·ª≠ l·∫°i sau.")
        else:
            logger.error(f"üÜò L·ªói API khi g·ª≠i /help: {e}")
            bot.reply_to(message, "üò• ƒê√£ c√≥ l·ªói x·∫£y ra khi hi·ªÉn th·ªã tr·ª£ gi√∫p.")
    except Exception as e:
        logger.error(f"üÜò L·ªói kh√¥ng mong mu·ªën khi g·ª≠i /help: {e}", exc_info=True)
        bot.reply_to(message, "üò• ƒê√£ c√≥ l·ªói x·∫£y ra khi hi·ªÉn th·ªã tr·ª£ gi√∫p.")

@bot.message_handler(commands=['top'])
@kiem_tra_nhom_cho_phep
def top_command(message: telebot.types.Message):
    user_id, user_name = get_user_info_from_message(message); logger.info(f"üèÜ User {user_id} ({user_name}) y√™u c·∫ßu xem /top.")
    game_data = load_game_data_sync();
    if not game_data: return bot.reply_to(message, "‚ÑπÔ∏è Hi·ªán t·∫°i ch∆∞a c√≥ d·ªØ li·ªáu ng∆∞·ªùi ch∆°i n√†o ƒë·ªÉ x·∫øp h·∫°ng.")
    player_list = []
    for uid_str, p_data in game_data.items():
        if isinstance(p_data, dict) and "xu" in p_data and "name" in p_data:
            # Chuy·ªÉn xu sang s·ªë ƒë·ªÉ s·∫Øp x·∫øp ƒë√∫ng
            player_xu = p_data.get("xu", 0)
            if not isinstance(player_xu, (int, float)): player_xu = 0 # ƒê·∫£m b·∫£o l√† s·ªë
            player_list.append({"id": uid_str, "name": p_data["name"], "xu": player_xu})
        else: logger.warning(f"‚ö†Ô∏è D·ªØ li·ªáu ng∆∞·ªùi ch∆°i kh√¥ng h·ª£p l·ªá trong /top cho ID {uid_str}: {p_data}")
    if not player_list: return bot.reply_to(message, "‚ÑπÔ∏è Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi ch∆°i h·ª£p l·ªá n√†o trong d·ªØ li·ªáu.")
    sorted_players = sorted(player_list, key=lambda p: p["xu"], reverse=True); top_players = sorted_players[:TOP_N]
    reply_lines = [f"üèÜ‚ú® <b>B·∫¢NG X·∫æP H·∫†NG TOP {len(top_players)} ƒê·∫†I GIA</b> ‚ú®üèÜ", "---------------------------------"]; ranks_emojis = ["ü•á", "ü•à", "ü•â"]
    for rank, player in enumerate(top_players, 1):
        rank_icon = ranks_emojis[rank-1] if rank <= len(ranks_emojis) else "üèÖ"
        safe_name = html.escape(player["name"]) # Escape t√™n ng∆∞·ªùi d√πng
        formatted_xu = format_xu(player["xu"])
        reply_lines.append(f"{rank_icon} {rank}. {safe_name} - üí∞ <b>{formatted_xu}</b> xu")
    reply_text = "\n".join(reply_lines); bot.reply_to(message, reply_text)

@bot.message_handler(commands=['info'])
@kiem_tra_nhom_cho_phep
def info_command(message: telebot.types.Message):
    user_id_to_check = None; args = message.text.split(); requesting_user_id, requesting_user_name = get_user_info_from_message(message)
    if message.reply_to_message:
        target_user = message.reply_to_message.from_user
        user_id_to_check = target_user.id
        logger.info(f"‚ÑπÔ∏è User {requesting_user_id} ({requesting_user_name}) y√™u c·∫ßu /info c·ªßa user {target_user.id} (qua reply).")
    elif len(args) > 1:
        try:
            user_id_to_check = int(args[1])
            logger.info(f"‚ÑπÔ∏è User {requesting_user_id} ({requesting_user_name}) y√™u c·∫ßu /info cho ID: {user_id_to_check}.")
        except ValueError:
            return bot.reply_to(message, "‚ùå ID ng∆∞·ªùi d√πng kh√¥ng h·ª£p l·ªá. Nh·∫≠p ID d·∫°ng s·ªë ho·∫∑c reply tin nh·∫Øn.")
    else:
        user_id_to_check = message.from_user.id
        logger.info(f"‚ÑπÔ∏è User {requesting_user_id} ({requesting_user_name}) y√™u c·∫ßu /info c·ªßa ch√≠nh m√¨nh.")

    if user_id_to_check:
        info_text = get_user_profile_info(user_id_to_check)
        bot.reply_to(message, info_text, disable_web_page_preview=True)
    else:
        bot.reply_to(message, "‚ùå Kh√¥ng th·ªÉ x√°c ƒë·ªãnh ng∆∞·ªùi d√πng c·∫ßn xem th√¥ng tin.")

@bot.message_handler(commands=['muavip'])
@kiem_tra_nhom_cho_phep
def muavip_telebot_command(message: telebot.types.Message):
    user_id, user_name = get_user_info_from_message(message)
    transfer_content = f"NAP VIP {user_id}"
    caption_text = f"""
üíé‚ú® <b>ƒêƒÉng K√Ω / Gia H·∫°n VIP</b> ‚ú®üíé
---------------------------------
üë§ Ng∆∞·ªùi d√πng: <b>{user_name}</b> (ID: <code>{user_id}</code>)
‚ú® Quy·ªÅn l·ª£i VIP: (Hi·ªán t·∫°i ch·ªß y·∫øu ƒë·ªÉ th·ªÉ hi·ªán, c√°c quy·ªÅn l·ª£i kh√°c c√≥ th·ªÉ ƒë∆∞·ª£c th√™m sau)
üí∞ Ph√≠ d·ªãch v·ª•: <b>{VIP_PRICE} / {VIP_DURATION_DAYS} ng√†y</b>
---------------------------------
üí≥ <b>Th√¥ng Tin Thanh To√°n:</b>
üè¶ Ng√¢n h√†ng: <b>{BANK_NAME}</b>
üî¢ S·ªë t√†i kho·∫£n: <code>{ACCOUNT_NUMBER}</code>
‚úçÔ∏è T√™n ch·ªß t√†i kho·∫£n: <b>{ACCOUNT_NAME}</b>
üí¨ N·ªôi dung CK: <code>{transfer_content}</code> (<b>‚ÄºÔ∏è QUAN TR·ªåNG ‚ÄºÔ∏è</b>)
---------------------------------
‚ö†Ô∏è <b>L∆∞u √Ω quan tr·ªçng:</b>
1Ô∏è‚É£ Chuy·ªÉn kho·∫£n ch√≠nh x√°c s·ªë ti·ªÅn v√† n·ªôi dung.
2Ô∏è‚É£ Sau khi CK th√†nh c√¥ng, <b>ch·ª•p l·∫°i bi√™n lai</b> giao d·ªãch.
3Ô∏è‚É£ Nh·∫•n n√∫t 'Li√™n H·ªá Admin' v√† g·ª≠i bi√™n lai k√®m ID <code>{user_id}</code> c·ªßa b·∫°n ƒë·ªÉ Admin k√≠ch ho·∫°t VIP.
‚ùì Th·∫Øc m·∫Øc? Nh·∫•n n√∫t 'Li√™n H·ªá Admin'.
"""
    markup = telebot.types.InlineKeyboardMarkup()
    btn_contact = telebot.types.InlineKeyboardButton(text="üëâ Li√™n H·ªá Admin X√°c Nh·∫≠n üëà", url=f"https://t.me/{ADMIN_USERNAME}")
    markup.add(btn_contact)
    try:
        if not QR_CODE_IMAGE_PATH.exists():
            logger.error(f"üÜò L·ªói /muavip: Kh√¥ng t√¨m th·∫•y ·∫£nh QR t·∫°i {QR_CODE_IMAGE_PATH}")
            return bot.reply_to(message, f"‚ùå L·ªói h·ªá th·ªëng: Kh√¥ng t√¨m th·∫•y m√£ QR thanh to√°n. Vui l√≤ng chuy·ªÉn kho·∫£n th·ªß c√¥ng theo th√¥ng tin tr√™n v√† li√™n h·ªá Admin (@{ADMIN_USERNAME}) ƒë·ªÉ x√°c nh·∫≠n.", reply_markup=markup)

        with open(QR_CODE_IMAGE_PATH, 'rb') as qr_photo:
             bot.send_photo(message.chat.id, photo=qr_photo, caption=caption_text, reply_markup=markup, reply_to_message_id=message.message_id)
        logger.info(f"üíé User {user_id} ({user_name}) ƒë√£ y√™u c·∫ßu xem th√¥ng tin /muavip.")
    except FileNotFoundError:
        logger.error(f"üÜò L·ªói FileNotFoundError /muavip: Kh√¥ng t√¨m th·∫•y {QR_CODE_IMAGE_PATH}")
        bot.reply_to(message, f"‚ùå L·ªói h·ªá th·ªëng: Kh√¥ng t√¨m th·∫•y file QR. Vui l√≤ng chuy·ªÉn kho·∫£n th·ªß c√¥ng theo th√¥ng tin tr√™n v√† li√™n h·ªá Admin (@{ADMIN_USERNAME}) ƒë·ªÉ x√°c nh·∫≠n.", reply_markup=markup)
    except Exception as e:
        logger.error(f"üÜò L·ªói kh√¥ng mong mu·ªën trong /muavip: {e}", exc_info=True)
        bot.reply_to(message, f"‚ùå ƒê√£ x·∫£y ra l·ªói khi g·ª≠i th√¥ng tin mua VIP. Vui l√≤ng th·ª≠ l·∫°i ho·∫∑c li√™n h·ªá Admin (@{ADMIN_USERNAME}).", reply_markup=markup)

@bot.message_handler(commands=['plan'])
@kiem_tra_nhom_cho_phep
def plan_command(message: telebot.types.Message):
    user_id, user_name = get_user_info_from_message(message)
    expiration_time = get_vip_expiration_time_from_db(user_id)
    now = datetime.now()
    if expiration_time and expiration_time > now:
        remaining_time = expiration_time - now
        days = remaining_time.days
        seconds = remaining_time.seconds
        hours = seconds // 3600
        minutes = (seconds % 3600) // 60
        parts = []
        if days > 0: parts.append(f"<b>{days}</b> ng√†y")
        if hours > 0: parts.append(f"<b>{hours}</b> gi·ªù")
        if minutes > 0: parts.append(f"<b>{minutes}</b> ph√∫t")
        if not parts and seconds > 0 : parts.append(f"<b>{seconds}</b> gi√¢y") # Ch·ªâ hi·ªÉn th·ªã gi√¢y n·∫øu kh√¥ng c√≥ ng√†y/gi·ªù/ph√∫t
        time_str = ", ".join(parts) if parts else "s·∫Øp h·∫øt h·∫°n"
        exp_str_formatted = expiration_time.strftime('%H:%M:%S ng√†y %d/%m/%Y')
        reply_text = (f"üëë {user_name}, b·∫°n ƒëang l√† th√†nh vi√™n <b>VIP</b>.\n"
                      f"üóìÔ∏è Th·ªùi gian c√≤n l·∫°i: ~{time_str}\n"
                      f"‚è≥ H·∫øt h·∫°n v√†o l√∫c: {exp_str_formatted}")
        bot.reply_to(message, reply_text)
        logger.info(f"‚ÑπÔ∏è User {user_id} ({user_name}) ki·ªÉm tra /plan: VIP c√≤n h·∫°n ƒë·∫øn {exp_str_formatted}")
    elif expiration_time and expiration_time <= now:
        exp_str_formatted = expiration_time.strftime('%d/%m/%Y')
        reply_text = f"üò• {user_name}, g√≥i VIP c·ªßa b·∫°n ƒë√£ h·∫øt h·∫°n v√†o ng√†y {exp_str_formatted}. H√£y d√πng <code>/muavip</code> ƒë·ªÉ gia h·∫°n nh√©!"
        bot.reply_to(message, reply_text)
        logger.info(f"‚ÑπÔ∏è User {user_id} ({user_name}) ki·ªÉm tra /plan: VIP ƒë√£ h·∫øt h·∫°n {exp_str_formatted}.")
    else:
        reply_text = f"‚ÑπÔ∏è {user_name}, b·∫°n ch∆∞a ph·∫£i l√† VIP. D√πng <code>/muavip</code> ƒë·ªÉ xem h∆∞·ªõng d·∫´n ƒëƒÉng k√Ω nha."
        bot.reply_to(message, reply_text)
        logger.info(f"‚ÑπÔ∏è User {user_id} ({user_name}) ki·ªÉm tra /plan: Ch∆∞a ph·∫£i VIP.")

@bot.message_handler(commands=['check'])
@kiem_tra_nhom_cho_phep
def check_command(message: telebot.types.Message):
    user_id, user_name = get_user_info_from_message(message)
    game_data = load_game_data_sync()
    player_data = get_player_data(user_id, user_name, game_data) # Kh√¥ng c·∫ßn save l·∫°i v√¨ ch·ªâ ƒë·ªçc
    bot.reply_to(message, f"üí∞ {user_name}, s·ªë d∆∞ c·ªßa b·∫°n l√†: <b>{format_xu(player_data['xu'])}</b> xu.")

@bot.message_handler(commands=['diemdanh'])
@kiem_tra_nhom_cho_phep
def diemdanh_command(message: telebot.types.Message):
    user_id, user_name = get_user_info_from_message(message)
    today_str = date.today().isoformat()
    game_data = load_game_data_sync()
    player_data = get_player_data(user_id, user_name, game_data)

    if player_data.get("last_checkin_date") == today_str:
        return bot.reply_to(message, f"üóìÔ∏è {user_name}, b·∫°n ƒë√£ ƒëi·ªÉm danh h√¥m nay r·ªìi. Mai l·∫°i gh√© nh√©! üòâ")

    # Ph·∫ßn th∆∞·ªüng ƒë√£ ƒë∆∞·ª£c l·∫•y t·ª´ CHECKIN_REWARD ƒë√£ thay ƒë·ªïi
    player_data["xu"] += CHECKIN_REWARD
    player_data["last_checkin_date"] = today_str
    save_game_data_sync(game_data)

    logger.info(f"üéÅ User {user_id} ({user_name}) th·ª±c hi·ªán /diemdanh (+{CHECKIN_REWARD}). Ng√†y: {today_str}")
    bot.reply_to(message, f"‚úÖ ƒêi·ªÉm danh ng√†y {date.today().strftime('%d/%m/%Y')} th√†nh c√¥ng!\nüéÅ B·∫°n nh·∫≠n ƒë∆∞·ª£c <b>{format_xu(CHECKIN_REWARD)}</b> xu.\nüí∞ S·ªë d∆∞ m·ªõi: <b>{format_xu(player_data['xu'])}</b> xu. Tuy·ªát v·ªùi! ‚ú®")

@bot.message_handler(commands=['time'])
@kiem_tra_nhom_cho_phep
def time_command(message: telebot.types.Message):
    now = datetime.now()
    uptime_delta = now - start_time
    total_seconds = int(uptime_delta.total_seconds())
    days, seconds_remaining = divmod(total_seconds, 86400)
    hours, seconds_remaining = divmod(seconds_remaining, 3600)
    minutes, seconds = divmod(seconds_remaining, 60)
    uptime_parts = []
    if days > 0: uptime_parts.append(f"{days} ng√†y")
    if hours > 0: uptime_parts.append(f"{hours} gi·ªù")
    if minutes > 0: uptime_parts.append(f"{minutes} ph√∫t")
    if seconds > 0 or not uptime_parts: uptime_parts.append(f"{seconds} gi√¢y")
    uptime_str = ", ".join(uptime_parts)
    bot.reply_to(message, f"‚è±Ô∏è Bot ƒë√£ ho·∫°t ƒë·ªông ƒë∆∞·ª£c: <b>{uptime_str}</b>.")
    logger.info(f"‚ÑπÔ∏è User {message.from_user.id} ({get_user_info_from_message(message)[1]}) y√™u c·∫ßu /time.")

@bot.message_handler(commands=['play'])
@kiem_tra_nhom_cho_phep
def play_command(message: telebot.types.Message):
    user_id, user_name = get_user_info_from_message(message)
    args = message.text.split()[1:]
    if len(args) != 2:
        return bot.reply_to(message, "‚ùå Sai c√∫ ph√°p! V√≠ d·ª•:\n<code>/play t√†i 10000</code>\n<code>/play x·ªâu all</code>")

    choice = args[0].lower()
    bet_input = args[1].lower()

    if choice not in ["t√†i", "x·ªâu"]:
        return bot.reply_to(message, "‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá. Ch·ªçn <b>t√†i</b> ho·∫∑c <b>x·ªâu</b> nha!")

    command_name = 'play'
    current_time = time.time()
    user_last_cmd_times = last_command_time.setdefault(user_id, {})
    last_play_time = user_last_cmd_times.get(command_name, 0)

    # Ki·ªÉm tra cooldown
    if current_time - last_play_time < PLAY_COOLDOWN:
        wait_time = round(PLAY_COOLDOWN - (current_time - last_play_time), 1)
        msg_wait = bot.reply_to(message, f"‚è≥ Ch∆°i ch·∫≠m l·∫°i ch√∫t n√†o! Vui l√≤ng ch·ªù <b>{wait_time} gi√¢y</b> n·ªØa nha.")
        # X√≥a tin nh·∫Øn ch·ªù v√† tin nh·∫Øn l·ªánh g·ªëc sau khi h·∫øt cooldown
        delete_message_after_delay(message.chat.id, msg_wait.message_id, wait_time + 1)
        delete_message_after_delay(message.chat.id, message.message_id, wait_time + 1)
        return

    game_data = load_game_data_sync()
    player_data = get_player_data(user_id, user_name, game_data)
    current_xu = player_data.get("xu", 0)
    bet_amount = 0

    if bet_input == "all":
        if current_xu <= 0:
            return bot.reply_to(message, f"üò• H·∫øt xu r·ªìi! H√£y /diemdanh ƒë·ªÉ nh·∫≠n th√™m nh√©!")
        bet_amount = current_xu
    else:
        try:
            bet_amount_str = bet_input.replace('.', '').replace(',', '') # X·ª≠ l√Ω d·∫•u ch·∫•m/ph·∫©y
            bet_amount = int(bet_amount_str)
            if bet_amount <= 0:
                return bot.reply_to(message, "‚ö†Ô∏è S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i l·ªõn h∆°n 0.")
        except ValueError:
            return bot.reply_to(message, "‚ö†Ô∏è Ti·ªÅn c∆∞·ª£c kh√¥ng h·ª£p l·ªá. Nh·∫≠p s·ªë ho·∫∑c 'all'.")

    if bet_amount > current_xu:
        return bot.reply_to(message, f"üò• Kh√¥ng ƒë·ªß <b>{format_xu(bet_amount)}</b> xu ƒë·ªÉ c∆∞·ª£c. B·∫°n c√≥: <b>{format_xu(current_xu)}</b> xu th√¥i.")

    logger.info(f"üé≤ User {user_id} ({user_name}) /play: C∆∞·ª£c {format_xu(bet_amount)} xu v√†o '{choice}'.")

    # Tr·ª´ ti·ªÅn tr∆∞·ªõc khi quay
    player_data["xu"] -= bet_amount
    player_data["plays"] = player_data.get("plays", 0) + 1
    user_last_cmd_times[command_name] = current_time # C·∫≠p nh·∫≠t th·ªùi gian ch∆°i cu·ªëi

    # Quay s·ªë
    dice, total, result = roll_dice_sync()
    dice_str = ' + '.join(map(str, dice))
    is_win = (choice == result)
    net_gain = 0
    jackpot_hit = False
    jackpot_win_amount = 0

    if is_win:
        # Th·∫Øng: Tr·∫£ l·∫°i ti·ªÅn c∆∞·ª£c + ti·ªÅn th·∫Øng (ƒë√£ tr·ª´ house edge)
        win_amount = round(bet_amount * (1 - (HOUSE_EDGE_PERCENT / 100.0)))
        net_gain = win_amount # S·ªë ti·ªÅn th·ª±c nh·∫≠n th√™m (kh√¥ng t√≠nh ti·ªÅn c∆∞·ª£c g·ªëc)
        player_data["xu"] += bet_amount + net_gain # Ho√†n ti·ªÅn c∆∞·ª£c + ti·ªÅn th·∫Øng

        # Ki·ªÉm tra Jackpot
        if random.randint(1, JACKPOT_CHANCE_ONE_IN) == 1:
            jackpot_hit = True
            jackpot_win_amount = JACKPOT_AMOUNT
            player_data["xu"] += jackpot_win_amount
            logger.info(f"üí• JACKPOT! User {user_id} ({user_name}) tr√∫ng {format_xu(jackpot_win_amount)} xu!")
    else:
        # Thua: ƒê√£ tr·ª´ ti·ªÅn c∆∞·ª£c ·ªü tr√™n r·ªìi
        net_gain = -bet_amount

    save_game_data_sync(game_data)

    result_icon = "üéØ" if is_win else "üí•"
    result_text_bold = f"<b>Th·∫Øng L·ªõn</b> üéâ" if is_win else f"<b>Thua R·ªìi</b> üò•"
    msg = (f"üé≤ <b>K·∫øt Qu·∫£ T√†i X·ªâu</b> üé≤\n--------------------------\n"
           f"üë§ Ng∆∞·ªùi ch∆°i: {user_name}\n"
           f"üëá B·∫°n ch·ªçn: <b>{choice.capitalize()}</b>\n"
           f"üé≤ K·∫øt qu·∫£: {dice_str} = {total} (<b>{result.capitalize()}</b>)\n"
           f"--------------------------\n"
           f"{result_icon} B·∫°n ƒë√£ {result_text_bold}!\n")

    if is_win:
        msg += f"‚ú® Th·∫Øng: <b>+{format_xu(net_gain)}</b> xu\n"
    if jackpot_hit:
        msg += f"<b>üíé??üíé N·ªî H≈® JACKPOT!!! +{format_xu(jackpot_win_amount)} xu üíéüíéüíé</b>\n"
    if not is_win: # Ch·ªâ hi·ªÉn th·ªã m·∫•t ti·ªÅn n·∫øu thua
        msg += f"üí∏ M·∫•t: <b>{format_xu(abs(net_gain))}</b> xu\n"

    msg += f"üí∞ S·ªë d∆∞ m·ªõi: <b>{format_xu(player_data['xu'])}</b> xu."
    bot.reply_to(message, msg)
    logger.info(f"Game Result /play: User:{user_id}, Dice:{dice}, Total:{total}, Result:{result}, Choice:{choice}, Bet:{bet_amount}, Win:{is_win}, Net:{net_gain}, Jackpot:{jackpot_hit}, NewBalance:{player_data['xu']}")

@bot.message_handler(commands=['baucua'])
@kiem_tra_nhom_cho_phep
def baucua_telebot_command(message: telebot.types.Message):
    user_id, user_name = get_user_info_from_message(message)
    args = message.text.split()[1:]
    valid_items_str = ", ".join([f"{BAUCUA_ICONS.get(item, '')}<code>{item}</code>" for item in BAUCUA_ITEMS])
    if len(args) != 2:
        return bot.reply_to(message, f"‚ùå Sai c√∫ ph√°p! V√≠ d·ª•:\n<code>/baucua cua 10000</code>\n<code>/baucua b·∫ßu all</code>\n<code>/baucua t√¥m 10k</code>\nC√°c v·∫≠t ph·∫©m: {valid_items_str}")

    choice = args[0].lower()
    bet_input = args[1].lower()

    if choice not in BAUCUA_ITEMS:
        valid_items_str_code = ", ".join([f"<code>{item}</code>" for item in BAUCUA_ITEMS])
        return bot.reply_to(message, f"‚ùå V·∫≠t ph·∫©m '<code>{html.escape(choice)}</code>' kh√¥ng h·ª£p l·ªá!\nCh·ªçn: {valid_items_str_code}")

    command_name = 'baucua'
    current_time = time.time()
    user_last_cmd_times = last_command_time.setdefault(user_id, {})
    last_baucua_time = user_last_cmd_times.get(command_name, 0)

    if current_time - last_baucua_time < BAUCUA_COOLDOWN:
        wait_time = round(BAUCUA_COOLDOWN - (current_time - last_baucua_time), 1)
        msg_wait = bot.reply_to(message, f"‚è≥ T·ª´ t·ª´ n√†o! Ch·ªù <b>{wait_time} gi√¢y</b> n·ªØa m·ªõi ch∆°i ti·∫øp ƒë∆∞·ª£c.")
        delete_message_after_delay(message.chat.id, msg_wait.message_id, wait_time + 1)
        delete_message_after_delay(message.chat.id, message.message_id, wait_time + 1)
        return

    game_data = load_game_data_sync()
    player_data = get_player_data(user_id, user_name, game_data)
    current_xu = player_data.get("xu", 0)
    bet_amount = 0
    multiplier = 1

    if bet_input != 'all':
        bet_str_num = bet_input
        if bet_input.endswith('k'):
            multiplier = 1000
            bet_str_num = bet_input[:-1]
        elif bet_input.endswith('m'):
            multiplier = 1000000
            bet_str_num = bet_input[:-1]
        try:
            bet_amount_str = bet_str_num.replace('.', '').replace(',', '') # X·ª≠ l√Ω d·∫•u ch·∫•m/ph·∫©y
            bet_amount = int(bet_amount_str) * multiplier
            if bet_amount <= 0:
                return bot.reply_to(message, "‚ö†Ô∏è S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i l·ªõn h∆°n 0.")
        except ValueError:
            return bot.reply_to(message, "‚ö†Ô∏è Ti·ªÅn c∆∞·ª£c kh√¥ng h·ª£p l·ªá. Nh·∫≠p s·ªë, 'all', ho·∫∑c d·∫°ng 10k, 1m.")
    elif bet_input == 'all':
         if current_xu <= 0:
             return bot.reply_to(message, f"üò• H·∫øt xu r·ªìi! H√£y /diemdanh ƒë·ªÉ nh·∫≠n th√™m nh√©!")
         bet_amount = current_xu
    else: # Tr∆∞·ªùng h·ª£p nh·∫≠p linh tinh kh√°c 'all' v√† s·ªë
        return bot.reply_to(message, "‚ö†Ô∏è Ti·ªÅn c∆∞·ª£c kh√¥ng h·ª£p l·ªá.")

    if bet_amount > current_xu:
        return bot.reply_to(message, f"üò• Kh√¥ng ƒë·ªß <b>{format_xu(bet_amount)}</b> xu. B·∫°n ch·ªâ c√≥: <b>{format_xu(current_xu)}</b> xu.")

    logger.info(f"ü¶Ä User {user_id} ({user_name}) /baucua: C∆∞·ª£c {format_xu(bet_amount)} xu v√†o '{choice}'.")

    # Tr·ª´ ti·ªÅn tr∆∞·ªõc
    player_data["xu"] -= bet_amount
    user_last_cmd_times[command_name] = current_time # C·∫≠p nh·∫≠t th·ªùi gian

    # Quay b·∫ßu cua
    results = roll_baucua_sync()
    results_icons = [BAUCUA_ICONS.get(item, item) for item in results]
    results_str_icons = " ".join(results_icons)
    results_str_text = ', '.join(results)
    match_count = results.count(choice)
    net_gain = 0

    if match_count > 0:
        # Th·∫Øng: Ho√†n ti·ªÅn c∆∞·ª£c + ti·ªÅn th·∫Øng (ti·ªÅn c∆∞·ª£c * s·ªë l·∫ßn xu·∫•t hi·ªán)
        win_multiplier = match_count
        net_gain = bet_amount * win_multiplier # Ti·ªÅn th·∫Øng th√™m
        player_data["xu"] += bet_amount + net_gain # Ho√†n c∆∞·ª£c + ti·ªÅn th·∫Øng
    else:
        # Thua: ƒê√£ tr·ª´ ti·ªÅn ·ªü tr√™n
        net_gain = -bet_amount

    save_game_data_sync(game_data)

    result_icon = "üéØ" if match_count > 0 else "üí•"
    result_text_bold = f"<b>Th·∫Øng</b> üéâ" if match_count > 0 else f"<b>Thua</b> üò•"
    choice_icon = BAUCUA_ICONS.get(choice, choice)

    msg = (f"ü¶Ä <b>K·∫øt Qu·∫£ B·∫ßu Cua</b> ü¶ê\n--------------------------\n"
           f"üë§ Ng∆∞·ªùi ch∆°i: {user_name}\n"
           f"üëá B·∫°n ch·ªçn: {choice_icon} (<code>{choice}</code>)\n"
           f"üé≤ K·∫øt qu·∫£: {results_str_icons} ({results_str_text})\n"
           f"--------------------------\n"
           f"{result_icon} B·∫°n ƒë√£ {result_text_bold}!\n")

    if match_count > 0:
        msg += f"‚ú® Th·∫Øng: <b>+{format_xu(net_gain)}</b> xu (xu·∫•t hi·ªán {match_count} l·∫ßn)\n"
    else:
        msg += f"üí∏ M·∫•t: <b>{format_xu(abs(bet_amount))}</b> xu\n"

    msg += f"üí∞ S·ªë d∆∞ m·ªõi: <b>{format_xu(player_data['xu'])}</b> xu."
    bot.reply_to(message, msg)
    logger.info(f"Game Result /baucua: User:{user_id}, Results:{results}, Choice:{choice}, Bet:{bet_amount}, Matches:{match_count}, Net:{net_gain}, NewBalance:{player_data['xu']}")

@bot.message_handler(commands=['qr'])
@kiem_tra_nhom_cho_phep
def qr_command(message: telebot.types.Message):
     user_id, user_name = get_user_info_from_message(message)
     text_to_encode = message.text.split(maxsplit=1)
     if len(text_to_encode) < 2 or not text_to_encode[1].strip():
         return bot.reply_to(message, "‚ùå Vui l√≤ng nh·∫≠p n·ªôi dung c·∫ßn t·∫°o m√£ QR.\nV√≠ d·ª•: <code>/qr N·ªôi dung c·∫ßn m√£ h√≥a</code>")

     content = text_to_encode[1].strip()
     logger.info(f"‚ñà User {user_id} ({user_name}) y√™u c·∫ßu t·∫°o QR: '{content[:50]}...'")
     try:
        qr = qrcode.QRCode( version=1, error_correction=qrcode.constants.ERROR_CORRECT_L, box_size=10, border=4 )
        qr.add_data(content)
        qr.make(fit=True)
        img = qr.make_image(fill_color="black", back_color="white")
        # L∆∞u v√†o buffer b·ªô nh·ªõ thay v√¨ file t·∫°m
        img_byte_arr = BytesIO()
        img.save(img_byte_arr, format='PNG')
        img_byte_arr.seek(0) # ƒê∆∞a con tr·ªè v·ªÅ ƒë·∫ßu buffer

        safe_caption_content = html.escape(content)
        max_caption_len = 200 # Gi·ªõi h·∫°n caption ƒë·ªÉ tr√°nh l·ªói Telegram
        if len(safe_caption_content) > max_caption_len:
            safe_caption_content = safe_caption_content[:max_caption_len] + "..."

        bot.send_photo(message.chat.id, photo=img_byte_arr, caption=f"‚ú® ƒê√¢y l√† m√£ QR c·ªßa b·∫°n cho:\n<code>{safe_caption_content}</code>", reply_to_message_id=message.message_id)
        logger.info(f"‚úÖ ƒê√£ t·∫°o v√† g·ª≠i QR th√†nh c√¥ng cho user {user_id}.")
     except Exception as e:
        logger.error(f"üÜò L·ªói khi t·∫°o ho·∫∑c g·ª≠i m√£ QR cho user {user_id}: {e}", exc_info=True)
        bot.reply_to(message, f"‚ùå ƒê√£ x·∫£y ra l·ªói khi t·∫°o m√£ QR: {html.escape(str(e))}")

@bot.message_handler(commands=['rutgon'])
@kiem_tra_nhom_cho_phep
def rutgon_command(message: telebot.types.Message):
    user_id, user_name = get_user_info_from_message(message)
    args = message.text.split(maxsplit=1)
    if len(args) < 2 or not args[1].strip():
        return bot.reply_to(message, "‚ùå Vui l√≤ng cung c·∫•p link URL mu·ªën r√∫t g·ªçn.\nV√≠ d·ª•: <code>/rutgon https://example.com/long/link</code>")

    url_to_shorten = args[1].strip()
    # Ki·ªÉm tra URL c∆° b·∫£n
    if not url_to_shorten.lower().startswith(('http://', 'https://')):
        return bot.reply_to(message, "‚ùå Link kh√¥ng h·ª£p l·ªá. Ph·∫£i b·∫Øt ƒë·∫ßu b·∫±ng <code>http://</code> ho·∫∑c <code>https://</code>.")

    logger.info(f"üîó User {user_id} ({user_name}) y√™u c·∫ßu r√∫t g·ªçn link: {url_to_shorten}")
    api_url = "https://cleanuri.com/api/v1/shorten"
    payload = {'url': url_to_shorten}
    waiting_msg = bot.reply_to(message, "‚è≥ ƒêang r√∫t g·ªçn link, ch·ªù ch√∫t...")

    try:
        response = requests.post(api_url, data=payload, timeout=10)
        response.raise_for_status() # N√©m l·ªói n·∫øu status code l√† 4xx ho·∫∑c 5xx
        result = response.json()

        if "error" in result:
            error_msg = result["error"]
            logger.error(f"‚ùå L·ªói t·ª´ API cleanuri khi r√∫t g·ªçn '{url_to_shorten}': {error_msg}")
            bot.edit_message_text(f"‚ùå L·ªói t·ª´ d·ªãch v·ª• r√∫t g·ªçn: {html.escape(error_msg)}", chat_id=waiting_msg.chat.id, message_id=waiting_msg.message_id)
            return

        short_url = result.get("result_url")
        if short_url:
            reply_text = (f"üîó Link g·ªëc: {html.escape(url_to_shorten)}\n"
                          f"‚ú® Link r√∫t g·ªçn: {short_url}")
            bot.edit_message_text(reply_text, chat_id=waiting_msg.chat.id, message_id=waiting_msg.message_id, disable_web_page_preview=True)
            logger.info(f"‚úÖ ƒê√£ r√∫t g·ªçn link '{url_to_shorten}' th√†nh '{short_url}' cho user {user_id}")
        else:
            logger.error(f"‚ùå API cleanuri kh√¥ng tr·∫£ v·ªÅ 'result_url' cho '{url_to_shorten}'. Ph·∫£n h·ªìi: {result}")
            bot.edit_message_text("‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh t·ª´ d·ªãch v·ª• r√∫t g·ªçn (kh√¥ng c√≥ result_url).", chat_id=waiting_msg.chat.id, message_id=waiting_msg.message_id)

    except requests.exceptions.Timeout:
        logger.error(f"‚è≥ Timeout khi g·ªçi API cleanuri cho link: {url_to_shorten}")
        bot.edit_message_text("‚è≥ Y√™u c·∫ßu r√∫t g·ªçn link b·ªã qu√° th·ªùi gian. Th·ª≠ l·∫°i sau.", chat_id=waiting_msg.chat.id, message_id=waiting_msg.message_id)
    except requests.exceptions.RequestException as e:
        logger.error(f"üÜò L·ªói k·∫øt n·ªëi API cleanuri: {e}", exc_info=True)
        error_detail = f" (Code: {e.response.status_code})" if e.response is not None else ""
        bot.edit_message_text(f"‚ùå L·ªói k·∫øt n·ªëi d·ªãch v·ª• r√∫t g·ªçn link{error_detail}.", chat_id=waiting_msg.chat.id, message_id=waiting_msg.message_id)
    except json.JSONDecodeError:
        logger.error(f"üÜò L·ªói gi·∫£i m√£ JSON t·ª´ API cleanuri: {url_to_shorten}")
        bot.edit_message_text("‚ùå L·ªói x·ª≠ l√Ω ph·∫£n h·ªìi t·ª´ d·ªãch v·ª• r√∫t g·ªçn (JSON kh√¥ng h·ª£p l·ªá).", chat_id=waiting_msg.chat.id, message_id=waiting_msg.message_id)
    except Exception as e:
        logger.error(f"üÜò L·ªói kh√¥ng mong mu·ªën trong /rutgon: {e}", exc_info=True)
        try:
            bot.edit_message_text("‚ùå ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën.", chat_id=waiting_msg.chat.id, message_id=waiting_msg.message_id)
        except Exception: # N·∫øu s·ª≠a tin nh·∫Øn c≈©ng l·ªói
             bot.reply_to(message, "‚ùå ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën.")

@bot.message_handler(commands=['thoitiet'])
@kiem_tra_nhom_cho_phep
def weather_command(message: telebot.types.Message):
    user_id, user_name = get_user_info_from_message(message)
    args = message.text.split(maxsplit=1)

    if not WEATHER_API_KEY or WEATHER_API_KEY == "YOUR_OPENWEATHERMAP_API_KEY":
        logger.warning(f"‚ö†Ô∏è User {user_id} d√πng /thoitiet nh∆∞ng API key ch∆∞a c·∫•u h√¨nh.")
        return bot.reply_to(message, "‚ö†Ô∏è T√≠nh nƒÉng th·ªùi ti·∫øt ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh. Li√™n h·ªá Admin.")

    if len(args) < 2 or not args[1].strip():
        return bot.reply_to(message, "‚ùå Vui l√≤ng nh·∫≠p t√™n th√†nh ph·ªë/ƒë·ªãa ƒëi·ªÉm.\nV√≠ d·ª•: <code>/thoitiet H√† N·ªôi</code>")

    location = args[1].strip()
    logger.info(f"üå¶Ô∏è User {user_id} ({user_name}) y√™u c·∫ßu th·ªùi ti·∫øt t·∫°i: '{location}'")
    base_url = "http://api.openweathermap.org/data/2.5/weather?"
    # units=metric ƒë·ªÉ l·∫•y ƒë·ªô C, lang=vi ƒë·ªÉ l·∫•y m√¥ t·∫£ ti·∫øng Vi·ªát
    complete_url = base_url + "appid=" + WEATHER_API_KEY + "&q=" + location + "&units=metric&lang=vi"
    waiting_msg = bot.reply_to(message, f"‚è≥ ƒêang l·∫•y th√¥ng tin th·ªùi ti·∫øt cho <code>{html.escape(location)}</code>...")

    try:
        response = requests.get(complete_url, timeout=10)
        response.raise_for_status()
        weather_data = response.json()

        # Ki·ªÉm tra m√£ ph·∫£n h·ªìi t·ª´ API (v√≠ d·ª•: 404 Not Found)
        if weather_data.get("cod") != 200:
            error_message = weather_data.get("message", "L·ªói kh√¥ng x√°c ƒë·ªãnh t·ª´ API")
            logger.error(f"‚ùå L·ªói t·ª´ API OpenWeatherMap (m√£ {weather_data.get('cod')}) cho '{location}': {error_message}")
            reply_error = f"‚ùå L·ªói t·ª´ d·ªãch v·ª• th·ªùi ti·∫øt: {html.escape(error_message)}"
            if "city not found" in error_message.lower():
                 reply_error = f"‚ùå Kh√¥ng t√¨m th·∫•y ƒë·ªãa ƒëi·ªÉm '<code>{html.escape(location)}</code>'."
            bot.edit_message_text(reply_error, chat_id=waiting_msg.chat.id, message_id=waiting_msg.message_id)
            return

        main = weather_data.get("main", {})
        weather_desc_list = weather_data.get("weather", [{}])
        weather_desc = weather_desc_list[0] if weather_desc_list else {}
        wind = weather_data.get("wind", {})
        sys_info = weather_data.get("sys", {})

        city_name = weather_data.get("name", location)
        country = sys_info.get("country", "")
        temp = main.get("temp", "N/A")
        feels_like = main.get("feels_like", "N/A")
        humidity = main.get("humidity", "N/A")
        description = weather_desc.get("description", "Kh√¥ng r√µ").capitalize()
        icon_code = weather_desc.get("icon")
        wind_speed = wind.get("speed", "N/A") # m/s

        # Mapping icon codes to emojis (c√≥ th·ªÉ m·ªü r·ªông th√™m)
        weather_icons = {
            "01d": "‚òÄÔ∏è", "01n": "üåô", "02d": "üå§Ô∏è", "02n": "‚òÅÔ∏è",
            "03d": "‚òÅÔ∏è", "03n": "‚òÅÔ∏è", "04d": "üå•Ô∏è", "04n": "‚òÅÔ∏è",
            "09d": "üåßÔ∏è", "09n": "üåßÔ∏è", "10d": "üå¶Ô∏è", "10n": "üåßÔ∏è",
            "11d": "‚õàÔ∏è", "11n": "‚õàÔ∏è", "13d": "‚ùÑÔ∏è", "13n": "‚ùÑÔ∏è",
            "50d": "üå´Ô∏è", "50n": "üå´Ô∏è"
        }
        icon_emoji = weather_icons.get(icon_code, "‚ùì") # Emoji m·∫∑c ƒë·ªãnh n·∫øu kh√¥ng c√≥ icon

        reply_text = (
            f"{icon_emoji} <b>Th·ªùi ti·∫øt t·∫°i {html.escape(city_name)}, {country}</b>\n"
            f"---------------------------------\n"
            f"üå°Ô∏è Nhi·ªát ƒë·ªô: <b>{temp}¬∞C</b> (C·∫£m gi√°c nh∆∞: {feels_like}¬∞C)\n"
            f"üíß ƒê·ªô ·∫©m: <b>{humidity}%</b>\n"
            f"üå¨Ô∏è Gi√≥: <b>{wind_speed} m/s</b>\n"
            f"üìù M√¥ t·∫£: <b>{html.escape(description)}</b>"
        )
        bot.edit_message_text(reply_text, chat_id=waiting_msg.chat.id, message_id=waiting_msg.message_id)
        logger.info(f"‚úÖ ƒê√£ g·ª≠i th·ªùi ti·∫øt '{location}' t·ªõi user {user_id}")

    except requests.exceptions.Timeout:
        logger.error(f"‚è≥ Timeout khi g·ªçi API OpenWeatherMap cho: {location}")
        bot.edit_message_text("‚è≥ Y√™u c·∫ßu th·ªùi ti·∫øt b·ªã qu√° th·ªùi gian. Th·ª≠ l·∫°i sau.", chat_id=waiting_msg.chat.id, message_id=waiting_msg.message_id)
    except requests.exceptions.RequestException as req_err:
        logger.error(f"üÜò L·ªói k·∫øt n·ªëi API OpenWeatherMap: {req_err}", exc_info=True)
        error_detail = f" (Code: {req_err.response.status_code})" if req_err.response is not None else ""
        bot.edit_message_text(f"‚ùå L·ªói k·∫øt n·ªëi d·ªãch v·ª• th·ªùi ti·∫øt{error_detail}.", chat_id=waiting_msg.chat.id, message_id=waiting_msg.message_id)
    except json.JSONDecodeError:
        logger.error(f"üÜò L·ªói gi·∫£i m√£ JSON t·ª´ API OpenWeatherMap: '{location}'")
        bot.edit_message_text("‚ùå L·ªói x·ª≠ l√Ω d·ªØ li·ªáu th·ªùi ti·∫øt (JSON kh√¥ng h·ª£p l·ªá).", chat_id=waiting_msg.chat.id, message_id=waiting_msg.message_id)
    except IndexError: # Tr∆∞·ªùng h·ª£p list 'weather' r·ªóng
        logger.error(f"üÜò IndexError khi x·ª≠ l√Ω d·ªØ li·ªáu th·ªùi ti·∫øt '{location}'.")
        bot.edit_message_text("‚ùå L·ªói d·ªØ li·ªáu th·ªùi ti·∫øt kh√¥ng ƒë·∫ßy ƒë·ªß t·ª´ API.", chat_id=waiting_msg.chat.id, message_id=waiting_msg.message_id)
    except Exception as e:
        logger.error(f"üÜò L·ªói kh√¥ng mong mu·ªën trong /thoitiet '{location}': {e}", exc_info=True)
        try:
             bot.edit_message_text("‚ùå ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën.", chat_id=waiting_msg.chat.id, message_id=waiting_msg.message_id)
        except Exception:
             bot.reply_to(message, "‚ùå ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën.")

@bot.message_handler(commands=['phim'])
@kiem_tra_nhom_cho_phep
def movie_command(message: telebot.types.Message):
    user_id, user_name = get_user_info_from_message(message)
    args = message.text.split(maxsplit=1)

    if not TMDB_API_KEY or TMDB_API_KEY == "YOUR_TMDB_API_KEY":
        logger.warning(f"‚ö†Ô∏è User {user_id} d√πng /phim nh∆∞ng API key TMDb ch∆∞a c·∫•u h√¨nh.")
        return bot.reply_to(message, "‚ö†Ô∏è T√≠nh nƒÉng t√¨m phim ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh. Li√™n h·ªá Admin.")

    if len(args) < 2 or not args[1].strip():
        return bot.reply_to(message, "‚ùå Vui l√≤ng nh·∫≠p t√™n phim b·∫°n mu·ªën t√¨m.\nV√≠ d·ª•: <code>/phim Inception</code>")

    query = args[1].strip()
    logger.info(f"üé¨ User {user_id} ({user_name}) t√¨m ki·∫øm phim: '{query}'")
    waiting_msg = bot.reply_to(message, f"‚è≥ ƒêang t√¨m phim '<code>{html.escape(query)}</code>'...")

    search_url = f"https://api.themoviedb.org/3/search/movie"
    params = {
        "api_key": TMDB_API_KEY,
        "query": query,
        "language": "vi-VN", # ∆Øu ti√™n ti·∫øng Vi·ªát
        "include_adult": False
    }

    try:
        # B∆∞·ªõc 1: T√¨m ki·∫øm phim
        response_search = requests.get(search_url, params=params, timeout=15)
        response_search.raise_for_status()
        search_results = response_search.json()

        # N·∫øu kh√¥ng c√≥ k·∫øt qu·∫£ ti·∫øng Vi·ªát, th·ª≠ ti·∫øng Anh
        if not search_results.get("results"):
            logger.info(f"Kh√¥ng t√¨m th·∫•y '{query}' (vi), th·ª≠ ti·∫øng Anh.")
            params["language"] = "en-US"
            response_search = requests.get(search_url, params=params, timeout=15)
            response_search.raise_for_status()
            search_results = response_search.json()

            if not search_results.get("results"):
                bot.edit_message_text(f"‚ùå Kh√¥ng t√¨m th·∫•y phim n√†o kh·ªõp v·ªõi '<code>{html.escape(query)}</code>'.", chat_id=waiting_msg.chat.id, message_id=waiting_msg.message_id)
                return

        # L·∫•y phim ƒë·∫ßu ti√™n trong k·∫øt qu·∫£
        movie = search_results["results"][0]
        movie_id = movie.get("id")

        if not movie_id:
            logger.error(f"‚ùå K·∫øt qu·∫£ t√¨m phim '{query}' kh√¥ng ch·ª©a ID. Data: {movie}")
            bot.edit_message_text(f"‚ùå L·ªói d·ªØ li·ªáu khi t√¨m phim '<code>{html.escape(query)}</code>'.", chat_id=waiting_msg.chat.id, message_id=waiting_msg.message_id)
            return

        # B∆∞·ªõc 2: L·∫•y chi ti·∫øt phim b·∫±ng ID (∆∞u ti√™n ti·∫øng Vi·ªát)
        details_url = f"https://api.themoviedb.org/3/movie/{movie_id}"
        details_params = {
            "api_key": TMDB_API_KEY,
            "language": "vi-VN",
            "append_to_response": "credits" # L·∫•y th√¥ng tin ƒë·∫°o di·ªÖn, di·ªÖn vi√™n
        }
        details = None
        try:
            details_response_vn = requests.get(details_url, params=details_params, timeout=15)
            if details_response_vn.status_code == 200:
                 details_vn = details_response_vn.json()
                 # Ki·ªÉm tra xem c√≥ ti√™u ƒë·ªÅ ti·∫øng Vi·ªát kh√¥ng, n·∫øu c√≥ th√¨ d√πng
                 if details_vn.get("title"):
                     details = details_vn
                     logger.info(f"‚úÖ L·∫•y chi ti·∫øt phim '{query}' (ID: {movie_id}) ti·∫øng Vi·ªát.")
        except requests.exceptions.RequestException as detail_err_vn:
             logger.warning(f"‚ö†Ô∏è L·ªói khi l·∫•y chi ti·∫øt phim TV ID {movie_id}: {detail_err_vn}")

        # N·∫øu kh√¥ng l·∫•y ƒë∆∞·ª£c ti·∫øng Vi·ªát ho·∫∑c kh√¥ng c√≥ ti√™u ƒë·ªÅ TV, th·ª≠ ti·∫øng Anh
        if not details:
            logger.info(f"Kh√¥ng c√≥ chi ti·∫øt TV ho·∫∑c l·ªói cho ID {movie_id}, th·ª≠ ti·∫øng Anh.")
            details_params["language"] = "en-US"
            details_response_en = requests.get(details_url, params=details_params, timeout=15)
            details_response_en.raise_for_status() # N√©m l·ªói n·∫øu ti·∫øng Anh c≈©ng l·ªói
            details = details_response_en.json()
            logger.info(f"‚úÖ L·∫•y chi ti·∫øt phim '{query}' (ID: {movie_id}) ti·∫øng Anh.")

        # Tr√≠ch xu·∫•t th√¥ng tin t·ª´ 'details'
        title = details.get("title", "N/A")
        original_title = details.get("original_title", "")
        tagline = details.get("tagline", "")
        overview = details.get("overview", "Kh√¥ng c√≥ m√¥ t·∫£.")
        release_date_str = details.get("release_date", "N/A") # YYYY-MM-DD
        runtime = details.get("runtime") # Ph√∫t
        genres_list = details.get("genres", [])
        genres = ", ".join([g["name"] for g in genres_list]) if genres_list else "N/A"
        rating = details.get("vote_average", 0)
        vote_count = details.get("vote_count", 0)
        poster_path = details.get("poster_path") # Ch·ªâ l√† ph·∫ßn cu·ªëi URL
        homepage = details.get("homepage")

        # L·∫•y ƒë·∫°o di·ªÖn v√† di·ªÖn vi√™n t·ª´ 'credits'
        director = "N/A"
        actors_list = []
        crew = details.get("credits", {}).get("crew", [])
        cast = details.get("credits", {}).get("cast", [])

        for member in crew:
            if member.get("job") == "Director":
                director = member.get("name", "N/A")
                break
        if cast:
            actors_list = [a.get("name", "") for a in cast[:5] if a.get("name")] # L·∫•y t·ªëi ƒëa 5 di·ªÖn vi√™n
        actors = ", ".join(actors_list) if actors_list else "N/A"

        # ƒê·ªãnh d·∫°ng l·∫°i th√¥ng tin
        runtime_str = "N/A"
        if isinstance(runtime, int) and runtime > 0:
            hours, minutes = divmod(runtime, 60)
            runtime_str = f"{hours}h {minutes}m" if hours > 0 else f"{minutes}m"

        rating_str = "Ch∆∞a ƒë√°nh gi√°"
        if vote_count > 0 and isinstance(rating, (float, int)) and rating > 0:
            rating_str = f"{rating:.1f}/10 ({vote_count:,} l∆∞·ª£t)"

        release_date_formatted = release_date_str
        try:
            if release_date_str and release_date_str != "N/A":
                release_dt = datetime.strptime(release_date_str, '%Y-%m-%d')
                release_date_formatted = release_dt.strftime('%d/%m/%Y')
        except ValueError:
            pass # Gi·ªØ nguy√™n ƒë·ªãnh d·∫°ng g·ªëc n·∫øu kh√¥ng parse ƒë∆∞·ª£c

        # Escape HTML cho an to√†n
        safe_title = html.escape(title)
        safe_original_title = f"<i>({html.escape(original_title)})</i>" if original_title and original_title != title else ""
        safe_tagline = f"<i>‚Äú{html.escape(tagline)}‚Äù</i>" if tagline else ""
        safe_genres = html.escape(genres)
        safe_director = html.escape(director)
        safe_actors = html.escape(actors)
        safe_overview = html.escape(overview or 'Ch∆∞a c√≥ m√¥ t·∫£.')
        max_overview_length = 350 # Gi·ªõi h·∫°n ƒë·ªô d√†i m√¥ t·∫£
        if len(safe_overview) > max_overview_length:
            safe_overview = safe_overview[:max_overview_length] + "..."

        caption = (
            f"üé¨ <b>{safe_title}</b> {safe_original_title}\n{safe_tagline}\n"
            f"---------------------------------\n"
            f"‚≠êÔ∏è ƒê√°nh gi√°: <b>{rating_str}</b>\n"
            f"üóìÔ∏è Ph√°t h√†nh: {release_date_formatted}\n"
            f"‚è±Ô∏è Th·ªùi l∆∞·ª£ng: {runtime_str}\n"
            f"üé≠ Th·ªÉ lo·∫°i: {safe_genres}\n"
            f"üé¨ ƒê·∫°o di·ªÖn: {safe_director}\n"
            f"üë• Di·ªÖn vi√™n: {safe_actors}\n"
            f"---------------------------------\n"
            f"üìù <b>N·ªôi dung:</b>\n{safe_overview}"
        )
        if homepage:
            caption += f"\n\nüîó Trang ch·ªß: {homepage}"

        # X√≥a tin nh·∫Øn ch·ªù
        try:
            bot.delete_message(chat_id=waiting_msg.chat.id, message_id=waiting_msg.message_id)
        except Exception:
            pass # B·ªè qua n·∫øu kh√¥ng x√≥a ƒë∆∞·ª£c

        # G·ª≠i k·∫øt qu·∫£ k√®m poster n·∫øu c√≥
        if poster_path:
            poster_url = f"https://image.tmdb.org/t/p/w500{poster_path}"
            try:
                # Gi·ªõi h·∫°n caption cho ·∫£nh (Telegram gi·ªõi h·∫°n 1024 k√Ω t·ª±)
                max_caption_length = 1024
                if len(caption) > max_caption_length:
                    caption = caption[:max_caption_length-25] + "...\n(N·ªôi dung b·ªã c·∫Øt b·ªõt)"

                bot.send_photo( message.chat.id, photo=poster_url, caption=caption, reply_to_message_id=message.message_id)
                logger.info(f"‚úÖ G·ª≠i phim '{title}' k√®m poster cho user {user_id}")
            except Exception as img_err:
                logger.warning(f"‚ö†Ô∏è L·ªói g·ª≠i ·∫£nh poster phim '{title}': {img_err}. G·ª≠i d·∫°ng vƒÉn b·∫£n.")
                # G·ª≠i l·∫°i d∆∞·ªõi d·∫°ng text n·∫øu g·ª≠i ·∫£nh l·ªói
                bot.reply_to(message, caption, disable_web_page_preview=True)
        else:
            # G·ª≠i text n·∫øu kh√¥ng c√≥ poster
            bot.reply_to(message, caption, disable_web_page_preview=True)
            logger.info(f"‚úÖ G·ª≠i phim '{title}' (kh√¥ng poster) cho user {user_id}")

    except requests.exceptions.Timeout:
        logger.error(f"‚è≥ Timeout khi g·ªçi API TMDb cho phim: {query}")
        bot.edit_message_text("‚è≥ Y√™u c·∫ßu t√¨m phim b·ªã qu√° th·ªùi gian.", chat_id=waiting_msg.chat.id, message_id=waiting_msg.message_id)
    except requests.exceptions.RequestException as req_err:
        logger.error(f"üÜò L·ªói k·∫øt n·ªëi API TMDb: {req_err}", exc_info=True)
        error_detail = f" (Code: {req_err.response.status_code})" if req_err.response is not None else ""
        bot.edit_message_text(f"‚ùå L·ªói k·∫øt n·ªëi d·ªãch v·ª• t√¨m phim{error_detail}.", chat_id=waiting_msg.chat.id, message_id=waiting_msg.message_id)
    except json.JSONDecodeError:
        logger.error(f"üÜò L·ªói gi·∫£i m√£ JSON t·ª´ API TMDb: '{query}'")
        bot.edit_message_text("‚ùå L·ªói x·ª≠ l√Ω d·ªØ li·ªáu phim (JSON kh√¥ng h·ª£p l·ªá).", chat_id=waiting_msg.chat.id, message_id=waiting_msg.message_id)
    except IndexError: # N·∫øu search_results["results"] r·ªóng sau c·∫£ 2 l·∫ßn th·ª≠
        logger.warning(f"‚ö†Ô∏è IndexError khi x·ª≠ l√Ω k·∫øt qu·∫£ t√¨m phim '{query}'.")
        # Tin nh·∫Øn n√†y ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω ·ªü ph·∫ßn ki·ªÉm tra results r·ªóng
        pass
    except Exception as e:
        logger.error(f"üÜò L·ªói kh√¥ng mong mu·ªën trong /phim '{query}': {e}", exc_info=True)
        try:
            bot.edit_message_text("‚ùå ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën.", chat_id=waiting_msg.chat.id, message_id=waiting_msg.message_id)
        except Exception:
             bot.reply_to(message, "‚ùå ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën.")

@bot.message_handler(commands=['fl'])
@kiem_tra_nhom_cho_phep
def follow_tiktok_command(message: telebot.types.Message):
    user_id, user_name = get_user_info_from_message(message)
    args = message.text.split(maxsplit=1)
    if len(args) < 2 or not args[1].strip():
        return bot.reply_to(message, "‚ùå Sai c√∫ ph√°p! Vui l√≤ng nh·∫≠p username TikTok.\nV√≠ d·ª•: <code>/fl tiktokusername</code>")

    tiktok_username = args[1].strip().replace('@', '') # X√≥a @ n·∫øu ng∆∞·ªùi d√πng nh·∫≠p v√†o
    if not tiktok_username:
        return bot.reply_to(message, "‚ùå Username TikTok kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng.")

    # T·∫°o URL API ƒë·ªông
    api_url = f"{TIKTOK_FL_API_BASE_URL}?user={tiktok_username}&userid={user_id}&tokenbot={BOT_TOKEN}"

    logger.info(f"üì≤ User {user_id} ({user_name}) y√™u c·∫ßu /fl cho TikTok: '{tiktok_username}'")
    waiting_msg = bot.reply_to(message, f"‚è≥ ƒêang g·ª≠i y√™u c·∫ßu tƒÉng follow cho <code>{html.escape(tiktok_username)}</code>... Ph√©p thu·∫≠t ƒëang di·ªÖn ra ‚ú®")

    api_success = False
    api_response_text = "Kh√¥ng c√≥ ph·∫£n h·ªìi c·ª• th·ªÉ."
    error_message_detail = None

    try:
        response = requests.get(api_url, timeout=25) # TƒÉng timeout l√™n 25s
        response.raise_for_status() # Ki·ªÉm tra l·ªói HTTP (4xx, 5xx)
        api_success = True
        api_response_text = response.text # L∆∞u l·∫°i text ph·∫£n h·ªìi ƒë·ªÉ debug
        logger.info(f"‚úÖ API Response /fl cho User {user_id}, TikTok '{tiktok_username}': {api_response_text}")

        # Th√¥ng b√°o th√†nh c√¥ng chung chung v√¨ kh√¥ng bi·∫øt API tr·∫£ v·ªÅ g√¨ c·ª• th·ªÉ
        success_reply = f"""‚ú® <b>Y√™u c·∫ßu TƒÉng Follow TikTok</b> ‚ú®\n‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\nüí¨ Tr·∫°ng th√°i: <code>Y√™u c·∫ßu ƒë√£ ƒë∆∞·ª£c g·ª≠i ƒëi!</code>\n‚úÖ K·∫øt qu·∫£: <b>Th√†nh c√¥ng</b> (Theo ph·∫£n h·ªìi t·ª´ API)\nüë§ T√™n Telegram: {user_name}\nüÜî ID Telegram: <code>{user_id}</code>\nüîó TikTok User: <code>@{html.escape(tiktok_username)}</code>\n‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\n‚ÑπÔ∏è <i>L∆∞u √Ω: Th·ªùi gian follow tƒÉng c√≥ th·ªÉ thay ƒë·ªïi t√πy thu·ªôc v√†o h·ªá th·ªëng.</i>"""
        bot.edit_message_text(success_reply, chat_id=waiting_msg.chat.id, message_id=waiting_msg.message_id)

    except requests.exceptions.Timeout:
        logger.error(f"‚è≥ Timeout khi g·ªçi API TikTok FL cho user {user_id}, TikTok '{tiktok_username}'")
        error_message_detail = "Y√™u c·∫ßu t·ªõi API b·ªã qu√° th·ªùi gian ch·ªù."
    except requests.exceptions.RequestException as e:
        status_code = "N/A"
        if e.response is not None:
            status_code = e.response.status_code
            api_response_text = e.response.text # L∆∞u l·∫°i text l·ªói t·ª´ API
            logger.error(f"üÜò L·ªói k·∫øt n·ªëi/API TikTok FL (Code: {status_code}) cho user {user_id}, TikTok '{tiktok_username}': {e}. Response: {api_response_text[:500]}")
            # C·ªë g·∫Øng ph√¢n t√≠ch l·ªói JSON n·∫øu c√≥
            try:
                error_json = e.response.json()
                if 'message' in error_json: error_message_detail = html.escape(error_json['message'])
                elif 'error' in error_json: error_message_detail = html.escape(error_json['error'])
                else: error_message_detail = f"L·ªói HTTP {status_code} t·ª´ API."
            except json.JSONDecodeError:
                 error_message_detail = f"L·ªói HTTP {status_code} t·ª´ API (Ph·∫£n h·ªìi kh√¥ng ph·∫£i JSON)."
        else:
            logger.error(f"üÜò L·ªói k·∫øt n·ªëi API TikTok FL (Kh√¥ng c√≥ ph·∫£n h·ªìi) cho user {user_id}, TikTok '{tiktok_username}': {e}", exc_info=True)
            error_message_detail = f"L·ªói k·∫øt n·ªëi m·∫°ng ho·∫∑c kh√¥ng nh·∫≠n ƒë∆∞·ª£c ph·∫£n h·ªìi t·ª´ API."

    except Exception as e:
        logger.error(f"üÜò L·ªói kh√¥ng mong mu·ªën trong /fl cho user {user_id}, TikTok '{tiktok_username}': {e}", exc_info=True)
        error_message_detail = "L·ªói kh√¥ng x√°c ƒë·ªãnh trong qu√° tr√¨nh x·ª≠ l√Ω."

    # X·ª≠ l√Ω n·∫øu API kh√¥ng th√†nh c√¥ng
    if not api_success:
        failure_reply = f"""‚ùå <b>Y√™u c·∫ßu TƒÉng Follow TikTok Th·∫•t B·∫°i</b> ‚ùå\n‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\nüí¨ Th√¥ng b√°o: <code>{error_message_detail or 'Kh√¥ng r√µ nguy√™n nh√¢n.'}</code>\nüìâ Tr·∫°ng th√°i: <b>Th·∫•t b·∫°i</b>\nüë§ T√™n Telegram: {user_name}\nüÜî ID Telegram: <code>{user_id}</code>\nüîó TikTok User: <code>@{html.escape(tiktok_username)}</code>\n‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\n‚ÑπÔ∏è <i>Vui l√≤ng th·ª≠ l·∫°i sau ho·∫∑c li√™n h·ªá Admin n·∫øu l·ªói ti·∫øp di·ªÖn.</i>"""
        try:
            bot.edit_message_text(failure_reply, chat_id=waiting_msg.chat.id, message_id=waiting_msg.message_id)
        except Exception as edit_err:
            logger.error(f"üÜò Kh√¥ng th·ªÉ s·ª≠a tin nh·∫Øn b√°o l·ªói /fl: {edit_err}")
            # G·ª≠i tin nh·∫Øn m·ªõi n·∫øu kh√¥ng s·ª≠a ƒë∆∞·ª£c
            bot.send_message(waiting_msg.chat.id, failure_reply, reply_to_message_id=message.message_id)

    # Log l·∫°i k·∫øt qu·∫£ cu·ªëi c√πng v√† ph·∫£n h·ªìi th√¥ (n·∫øu c√≥) ƒë·ªÉ debug
    logger.info(f"K·∫øt qu·∫£ /fl: Success={api_success}, User={user_id}, TikTok='{tiktok_username}'. Raw Response (n·∫øu c√≥): {api_response_text}")

@bot.message_handler(commands=['flauto'])
@kiem_tra_nhom_cho_phep
def flauto_command(message: telebot.types.Message):
    user_id, user_name = get_user_info_from_message(message)
    args = message.text.split(maxsplit=1)

    if len(args) < 2 or not args[1].strip():
        return bot.reply_to(message, f"‚ùå Sai c√∫ ph√°p! Vui l√≤ng nh·∫≠p username TikTok.\nV√≠ d·ª•: <code>/flauto tiktokusername</code>\nChi ph√≠: <b>{format_xu(FLAUTO_COST)} xu</b>.\nCh·∫°y m·ªói: <b>{FLAUTO_INTERVAL_MINUTES} ph√∫t</b>.")

    tiktok_username = args[1].strip().replace('@', '')
    if not tiktok_username:
        return bot.reply_to(message, "‚ùå Username TikTok kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng.")

    with scheduler_lock: # Kh√≥a ƒë·ªÉ ki·ªÉm tra v√† th√™m t√°c v·ª• an to√†n
        if user_id in auto_follow_tasks:
            active_task = auto_follow_tasks[user_id]
            next_run_time = "Kh√¥ng x√°c ƒë·ªãnh"
            try:
                # C·ªë g·∫Øng l·∫•y th·ªùi gian ch·∫°y ti·∫øp theo
                if hasattr(active_task['job'], 'next_run'):
                    next_run_dt = active_task['job'].next_run
                    if next_run_dt:
                         next_run_time = next_run_dt.strftime('%H:%M:%S %d/%m/%Y')
            except Exception as time_err:
                logger.warning(f"Kh√¥ng th·ªÉ l·∫•y next_run cho job c·ªßa user {user_id}: {time_err}")

            return bot.reply_to(message, f"‚ö†Ô∏è B·∫°n ƒë√£ c√≥ m·ªôt t√°c v·ª• t·ª± ƒë·ªông tƒÉng follow ƒëang ch·∫°y cho <b>@{html.escape(active_task['tiktok_username'])}</b>.\n(D·ª± ki·∫øn ch·∫°y l·∫ßn t·ªõi: {next_run_time})\nD√πng l·ªánh <code>/stopflauto</code> ƒë·ªÉ h·ªßy tr∆∞·ªõc khi t·∫°o c√°i m·ªõi.")

        # Ki·ªÉm tra ti·ªÅn tr∆∞·ªõc khi lock data
        temp_game_data = load_game_data_sync()
        temp_player_data = get_player_data(user_id, user_name, temp_game_data) # Ch·ªâ ƒë·ªçc, ch∆∞a s·ª≠a
        if temp_player_data['xu'] < FLAUTO_COST:
            return bot.reply_to(message, f"üò• B·∫°n kh√¥ng ƒë·ªß <b>{format_xu(FLAUTO_COST)}</b> xu ƒë·ªÉ k√≠ch ho·∫°t.\nB·∫°n ƒëang c√≥: <b>{format_xu(temp_player_data['xu'])}</b> xu.")
        del temp_game_data # Gi·∫£i ph√≥ng b·ªô nh·ªõ t·∫°m

        # N·∫øu ƒë·ªß ti·ªÅn, th·ª±c hi·ªán tr·ª´ ti·ªÅn v√† l√™n l·ªãch
        game_data = load_game_data_sync()
        player_data = get_player_data(user_id, user_name, game_data)
        player_data['xu'] -= FLAUTO_COST
        save_game_data_sync(game_data)
        logger.info(f"üí∏ User {user_id} ({user_name}) ƒë√£ chi {FLAUTO_COST} xu ƒë·ªÉ k√≠ch ho·∫°t /flauto cho @{tiktok_username}.")

        # L√™n l·ªãch t√°c v·ª•
        job = schedule.every(FLAUTO_INTERVAL_MINUTES).minutes.do(_run_auto_follow, user_id=user_id, tiktok_username=tiktok_username)
        auto_follow_tasks[user_id] = {'tiktok_username': tiktok_username, 'job': job}

        bot.reply_to(message, f"‚úÖ ƒê√£ k√≠ch ho·∫°t t·ª± ƒë·ªông tƒÉng follow cho <b>@{html.escape(tiktok_username)}</b> m·ªói <b>{FLAUTO_INTERVAL_MINUTES} ph√∫t</b>.\nüí∞ ƒê√£ tr·ª´ <b>{format_xu(FLAUTO_COST)}</b> xu. S·ªë d∆∞ m·ªõi: <b>{format_xu(player_data['xu'])}</b> xu.\nD√πng <code>/stopflauto</code> ƒë·ªÉ h·ªßy.")
        logger.info(f"‚è∞ [AutoFL] ƒê√£ l√™n l·ªãch t√°c v·ª• cho User {user_id}, TikTok '{tiktok_username}', Interval: {FLAUTO_INTERVAL_MINUTES} ph√∫t.")

@bot.message_handler(commands=['stopflauto'])
@kiem_tra_nhom_cho_phep
def stop_flauto_command(message: telebot.types.Message):
    user_id, user_name = get_user_info_from_message(message)

    with scheduler_lock: # Kh√≥a ƒë·ªÉ ki·ªÉm tra v√† h·ªßy t√°c v·ª• an to√†n
        if user_id not in auto_follow_tasks:
            return bot.reply_to(message, "‚ÑπÔ∏è B·∫°n kh√¥ng c√≥ t√°c v·ª• t·ª± ƒë·ªông tƒÉng follow n√†o ƒëang ch·∫°y.")

        try:
            task_info = auto_follow_tasks[user_id]
            tiktok_username = task_info['tiktok_username']
            job_to_cancel = task_info['job']

            schedule.cancel_job(job_to_cancel)
            del auto_follow_tasks[user_id]

            logger.info(f"üõë [AutoFL] User {user_id} ({user_name}) ƒë√£ h·ªßy t√°c v·ª• t·ª± ƒë·ªông cho @{tiktok_username}.")
            bot.reply_to(message, f"‚úÖ ƒê√£ h·ªßy t√°c v·ª• t·ª± ƒë·ªông tƒÉng follow cho <b>@{html.escape(tiktok_username)}</b> th√†nh c√¥ng.")

        except Exception as e:
            logger.error(f"üÜò L·ªói khi h·ªßy t√°c v·ª• /stopflauto cho user {user_id}: {e}", exc_info=True)
            bot.reply_to(message, "‚ùå ƒê√£ x·∫£y ra l·ªói khi c·ªë g·∫Øng h·ªßy t√°c v·ª• c·ªßa b·∫°n.")

@bot.message_handler(commands=['admin'])
@kiem_tra_nhom_cho_phep
def admin_contact_command(message: telebot.types.Message):
     user_id, user_name = get_user_info_from_message(message)
     bot.reply_to(message, f"üßë‚Äçüíº C·∫ßn h·ªó tr·ª£? Li√™n h·ªá qu·∫£n tr·ªã vi√™n ngay: @{ADMIN_USERNAME} ‚ú®")
     logger.info(f"‚ÑπÔ∏è User {user_id} ({user_name}) y√™u c·∫ßu th√¥ng tin li√™n h·ªá admin.")

# === Kh·ªüi ch·∫°y Bot ===
def main():
    logger.info("--- üöÄ Bot ƒëang kh·ªüi t·∫°o üöÄ ---")
    initialize_vip_database()
    load_vip_users_from_db()
    _ = load_game_data_sync() # Load data game ban ƒë·∫ßu ƒë·ªÉ ƒë·∫£m b·∫£o file t·ªìn t·∫°i/h·ª£p l·ªá

    # <<< TH√äM M·ªöI - Kh·ªüi ch·∫°y lu·ªìng cho scheduler >>>
    scheduler_thread = threading.Thread(target=_scheduler_loop, daemon=True)
    scheduler_thread.start()
    logger.info("‚úÖ Lu·ªìng Scheduler ƒë√£ ƒë∆∞·ª£c kh·ªüi ch·∫°y.")
    # <<< K·∫æT TH√öC PH·∫¶N TH√äM M·ªöI >>>

    logger.info(f"üîí Bot s·∫Ω ch·ªâ ho·∫°t ƒë·ªông trong nh√≥m ID: {ALLOWED_GROUP_ID}")
    logger.info(f"üîë Bot Token: ...{BOT_TOKEN[-6:]}")
    logger.info(f"üëë Admin ID: {ADMIN_ID} | Admin Username: @{ADMIN_USERNAME}")
    logger.info(f"üí∞ ƒêi·ªÉm danh: {format_xu(CHECKIN_REWARD)} xu | AutoFL Cost: {format_xu(FLAUTO_COST)} xu")
    logger.info(f"üíæ Game Data File: {DATA_FILE_PATH}")
    logger.info(f"üíé VIP DB File: {DB_FILE_PATH}")
    logger.info(f"üí≥ VIP QR Code Image: {QR_CODE_IMAGE_PATH}")
    logger.info(f"‚ú® TikTok FL API: {TIKTOK_FL_API_BASE_URL}")
    logger.info(f"‚è∞ Bot b·∫Øt ƒë·∫ßu ch·∫°y l√∫c: {start_time.strftime('%Y-%m-%d %H:%M:%S')}")
    logger.info("--- üéâ Bot ƒë√£ s·∫µn s√†ng tung ho√†nh! üéâ ---")
    try:
        bot.infinity_polling(logger_level=logging.INFO, skip_pending=True) # ƒê·ªïi level log polling th√†nh INFO
    except Exception as e:
        logger.critical(f"‚ÄºÔ∏èüÜò L·ªñI NGHI√äM TR·ªåNG KHI·∫æN BOT D·ª™NG HO·∫†T ƒê·ªòNG: {e}", exc_info=True)
    finally:
        logger.info("--- Bot ƒëang d·ª´ng... H·∫πn g·∫∑p l·∫°i! üëã ---")
        # <<< TH√äM M·ªöI - D·ªçn d·∫πp schedule khi d·ª´ng bot >>>
        schedule.clear()
        logger.info("üßπ ƒê√£ x√≥a t·∫•t c·∫£ c√°c t√°c v·ª• schedule ƒëang ch·ªù.")
        # <<< K·∫æT TH√öC PH·∫¶N TH√äM M·ªöI >>>
        logger.info("--- Bot ƒë√£ d·ª´ng ho√†n to√†n ---")

if __name__ == '__main__':
    # Nh·∫Øc nh·ªü c√†i ƒë·∫∑t th∆∞ vi·ªán c·∫ßn thi·∫øt
    try:
        import schedule
    except ImportError:
        print("L·ªói: Th∆∞ vi·ªán 'schedule' ch∆∞a ƒë∆∞·ª£c c√†i ƒë·∫∑t.")
        print("Vui l√≤ng ch·∫°y: pip install schedule")
        exit() # Tho√°t n·∫øu ch∆∞a c√†i

    main()
